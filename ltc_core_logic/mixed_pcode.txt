    
    
    // 
        五分钟以内必须写出伪代码
        和孤独和解，甚至一辈子又可以不用主动找别人交流
            社交在本质上可分为两种。一种是共情社交，一种是功利社交
            在生活中那些越成熟、越独立的人就越是对共情社交不在乎。
            他们的人格和在社会上生存的能力足够完善，无论是情感还是物质，他们都不需要「朋友」来给他们提供支持    作者：恒生ETF  链接：https://xueqiu.com/9675645130/111889108  来源：雪球  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  风险提示：本文所提到的观点仅代表个人的意见，所涉及标的不作推荐，据此买卖，风险自负。
            * 人格和在社会上生存的能力
            * 较为「对等」的价值水平
            那如果这个翻得一手好跟头的人也同时渴望一个有钱的朋友，那你们的价值水平就算是「对等」的    作者：恒生ETF  链接：https://xueqiu.com/9675645130/111889108  来源：雪球  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  风险提示：本文所提到的观点仅代表个人的意见，所涉及标的不作推荐，据此买卖，风险自负。
            而如果这个翻得一手好跟头的人视金钱如粪土，他只喜欢会踩高跷的朋友，那你这个百万富翁对他而言就是无意义的，你们的价值水平就并不对等    作者：恒生ETF  链接：https://xueqiu.com/9675645130/111889108  来源：雪球  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  风险提示：本文所提到的观点仅代表个人的意见，所涉及标的不作推荐，据此买卖，风险自负。
            如果一个人和你的差距极大，你很清楚这个人在未来的生活中不可能给你带来丝毫的利益，那么这段社交关系对于你而言就是无价值的    作者：恒生ETF  链接：https://xueqiu.com/9675645130/111889108  来源：雪球  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  风险提示：本文所提到的观点仅代表个人的意见，所涉及标的不作推荐，据此买卖，风险自负。
            * 社交边界
            中国式边界不清的社交模式
            人因为害怕被遗忘，希望别人随时找到自己
            世界这么大，我竟不知道联系谁。
            社交是人类判别自我存在价值，定位自我认同自我的一个必要之物
            自我存在价值
            自我认同
            人自我的存在需要对应的坐标来衡量
            没有其他人的存在，没有社交的存在，那么你所做的一切都没有对与错，值得与不值得的参照物存在了。
            这种没有参照的虚脱感会给智慧生物带来无比的痛苦感
            没有世俗就没有超凡，没有愚昧就没有智慧
            远方是什么？我以为是生活在别处，是独立追求梦想，是拥有知己和爱人，是像三毛那样在撒哈拉流浪，追求“诗和远方”仿佛成了出国留学最好的注脚。
            这是一段漫长且孤独的旅程
            我们当时以为可以拥有的自由和成就，其实被淹没在了很多细小的事情里与琐碎的自我怀疑中
            真正的归属感是我们学会和孤独和解，是发自内心地认为，孤独不是一件可耻的事情，它只是生活的一种状态。
            * 和孤独和解
            在国外念大学是自由的，拥有各种价值观和文化历史的人在这里交织纠缠
            实际上这样的形式还是太过外在了
            * 内心真正强大和平静的人实际上是不屑于用外在的东西来包装自己的。
                因为脑子里都是东西
            内心真正强大
            归属感不是来自于一群人的热闹，而是来自一个人独处的时刻
            对于这座城市来说，大家都是不问来路的过客和归人
            每个人都像举着蜡烛在探路的旅人
            不忘初心，方得始终，也是这段旅途的终极奥义
            人终其一生都在寻找灵魂上的归宿，所以我们需要家庭，需要工作，需要财富。在寻找的过程中，许多人想通过酒精，通过性，或是不成熟的情感来找到这种契合
            孤独使人清醒，孤独也使人坚强，在这喧闹的世界中，能找到心灵上的一方宁静，实在是一件幸事。
            * 大多数老外蠢萌抠逼自恋但是没有人真心乐意去费劲儿害你，跟国人之间甄嬛传不太一样
            学习专治所有神经病
            活着就是受罪的 大家都难
            想要摘星星的孩子，    孤独是我们的必修课，
            每天从清晨睁开眼到夜晚入眠，    都在用不够好的英文和老师同学交流。
            习惯并享受了一个人的充实自在。
            孤独的同时带来了自由
        不管怎么样idea一定要熟悉，特别熟悉
        &toimp
        key points:
            idea: 
            pcode:
            io: 
            realc++: 

            --
            idea:
            c++imp:

            --
            stru-operation-pcode:
                insert 
                delete 
                substitute 
                search 
        ** 百分之八十的算法都可以用简单的一个文件中从头写，剩下的需要fw去测试
            而图形学科研关注的是百分之5的用非常复杂的fw才可以测试的算法.......
            所以从头码代码的能力很弱.....
        * 先不考虑集成，积累snippets！！！刷题其实是在丰富笔记！！！
        * 那些acmer高手，看似思路很快，其实就是知道的套路比你多
        pcode indicats ...
        网上资源其实也不少，但是总觉得不踏实，不系统
        题目肯定是无穷多的， tasks不可估计。但是知识点是有限的。
            不要被无限多的题目迷惑了双眼，掌握核心知识以后你也可以出题！
            所以有些题目没有看到也并不遗憾
            但是还是尽力多做题！整理他们的精华之处！   
        type of tasks: 
            DS free tasks
            lan-feature based
        算法是别人或者自己的，那怎么叫熟悉的语言？
            所有小task都可以毫不费力没有参考或者只参考笔记完成
            -这需要训练
                1.理解并设计tiny tasks 
                2.反复实现
        熟悉c++语言
            基本的概念了如指掌
            所有task信手拈来
        tasks 
            在fw中input怎么办？ -- hardcoded, in a header file!
            输出？ 横线作为标志 
        编程和语言很像，都是模仿。深层次的模仿叫创造，浅层次的模仿叫抄袭
        *如何积累？学cpp面向对象，数据结构，算法有什么不同？ 
            学cpp面向对象--没有错误就ok--self containing tasks --积累tasks(完整的)
            数据结构--没有错误就ok--积累tasks(完整的)
            算法--结果正确，高效--
                base case
                    积累tasks(完整的) + static test cases（不完整）
                integrated 
                    积累snippets！（不完整）
                (mixed!complicated!)
            项目功能--积累snippets！（不完整）
            ---
                (如何集成？-- methods based 
                    test1(){}
                    test2(){}
                    ...
                    int main(){
                        test1();
                    }
                越低的lev代码段越小，不必要snippet备份！ 
        *task based training
            the right ones, and improve
            bkp
            rewrite and ref. to bkp 
        code reuse? --> ref. to pieces!
        code judgement? 
            + 
            initial ideas: 
                test cases, unit test(expected input output, use assert func.) -- have seen someone uses 
                    consider about corner cases! software test! 
                    use standard methods to gen. test cases!! 
                benchmark
                    a larger version of test cases!
                    for computer vision, machine learning 
                vis it!, plot it out, we can easily judge it! 
                    for graphics 
        A simple and complete C++ program demonstration should be summ. 
        modeling skills also needed! 
            modeling + coding
        boost your cpu 
        不要通过ACM这种形式来学习，性价比太低。
    ---
    summ_mixed:
        * 语言相关工具方法:
            qq gen. random float number bet. 1 to 100??
                std::random_device rd;
                std::mt19937 mt(rd());
                std::uniform_real_distribution<> dist(0, 1);
            qq gen. in the range 1985-2014 
            qq read write file??
            qq plot with py?
            qq print arr?
                void print_array(int* arr, int size) {
                    for (int i = 0; i < size; i++) {
                        cout << arr[i] << " ";
                    }
                    cout << "\n";
                }
            C++的内存分区管理方式
                在C++中，内存分为5个区：堆、占、自由存储区、全局/静态存储区、常量存储区
                栈：是由编译器在需要时自动分配，不需要时自动清除的变量存储区。通常存放局部变量、函数参数等
                堆：是由new分配的内存块，由程序员释放（编译器不管）
                自由存储区：是由malloc等分配的内存块，和堆十分相似，用free来释放。
                全局/静态存储区：全局变量和静态变量被分配到同一块内存中（在C语言中，全局变量又分为初始化的和未初始化的，C++中没有这一区分）
                常量存储区：这是一块特殊存储区，里边存放常量，不允许修改。
                5个区
                new可以看成是malloc智能化的高级版本，详情参见new和malloc的区别及实现方法
        * 各种数据结构new
            //
                有stl的实现就用stl的， poj中是可以用stl库的！ 
                * 会增删改查，会基本习题
                (based on stl)
                所有结构都了解了？？
                以node的结构为核心，实现各种结构和功能
                为啥一些算法可以不用默写？
                    * 本身作者可能也不会
                    * 只是一个高效的解决，没特殊必要其实可以用简单的算法替代
                        其实从题目的角度来讲，一般也不需要那么高效
                        用红黑树做的用基本的BST也可以做
                    你必须知道什么时候BST对于一个问题是个有效的解法
                    学习什么时候以及如何将不同的数据结构运用到自己的代码里
                    什么时候需要hash？什么时候需要tree？什么时候最小化堆是正确的答案？
                    也就是要强调modeling的重要性
                    最好再就一个具体的操作系统（比如xv6）研究这些原理是怎么应用的；而不是开机启动的详细步骤，当然你知道最好
                    “这个设计/算法为什么是这样的，而不是那样的。如果让我来解决这个问题，我会怎么做”。
                    这些基础课不是计算机领域这张大地图上零散的点，它们可以通过“抽象”来实现“分层”，“分层”的目的是让你更容易看清楚这些课的关系
                    要记住这些算法到底解决了什么问题，有哪些好处，以及其中的一些线索，可以在需要的时候自己重新推导出来
                    算法到底解决了什么问题，有哪些好处
                    我没有听说有人遇到考核红黑树的实现细节的面试官
                    红黑树是一种常用的平衡二叉搜索树，单次的查找、插入、删除的复杂度都是lg(n)
                    STL中的map和set是用红黑树实现的，以及它们的用法
                    虽然在校招中不太可能有面试官要求手写KMP算法，但是有可能有面试官会让你解释KMP的原理
                    解释KMP的原理
                    应试做准备的话，应该优先练习链表类题目和二叉树类题目
                    KMP的精髓就在于，用了一个线性的算法，得到了每次在pat[ j ]发生失配时
                    算法的复杂度是O(N + M).
                    还有直接问一个算法的算法复杂度的，最后的公式还一点都不简单，你打算现场重新推一遍么？推错了，咋办？
                    不要死记，记原理，或者记类似算法，比如我不会kmp
                    面试官问到的话就说一般用简单的bm，比kmp实用，如果面试官只卡你一个特定算法，要么是岗位太特殊，要么不值得去
                    你当面试的官有几个能默写出红黑树代码的。。。。
                    别说红黑树的全部算法了。就连最常见的AVL的插入重建平衡，我估计也只有1/2能写出来..删除,我估计99.9就没考虑过这个问题.
                    如果有人问你红黑树.你答清楚大致原理,随便说说AVL的插入重建平衡.我估计你这个面试题就过了.
                    如果面试真要现场手工打造高保真红黑树算法，一旦你写出来了，吐血的就是面试官了。
                    手写基本算法
                    我以前面试考察的手写基本算法： 
                        二叉树 API（查找、插入、删除、前继、后继、前序/中序/后序遍历(递归和迭代)） 
                        堆 API（上浮、下沉、建堆、堆排序） 
                        快速排序 二分搜索 
                        图的 DFS/BFS、
                        拓扑排序、Dijkstra
                    虽然 LC 周赛最后一道题经常是 DP，
                        但国内面试考 DP 的还是少，上面这些能写出来就相当不错了……
                    就算被问到，这里也有比KMP更简单的算法：Rabin-Karp
                    Rabin-Karp算法的特点是不需要背，你只要懂它的原理，就可以写出代码了。
                    Rabin-Karp
                    https://pic3.zhimg.com/80/v2-26e03e24d67c0b6d89f3097af95ecc5f_1440w.jpg
                    
                    对于一些特殊的树，例如红黑树（Red-Black Tree）、自平衡二叉搜索树（AVL Tree），大家不必花费太多时间去准备，一般在面试中不会被问到，除非你所涉及的研究领域跟它们相关或者你十分感兴趣
                    在面试中常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）
                    树的结构十分直观，而树的很多概念定义都有一个相同的特点：递归，也就是说，一棵树要满足某种性质，往往要求每个节点都必须满足
                    大部分关于树的面试题都与递归有关
                    换句话说，面试官希望通过一道关于树的问题来考察你对于递归算法掌握的熟练程度
                    无论你是前端工程师，还是后端工程师，在准备面试的时候，树这个数据结构可以说是最应该花时间学习的。
                    掌握好树，能证明你对递归有很好的认识，能帮助你学习图论。另外，树的许多性质都是面试的热门考点，尤其是二叉搜索树（BST）。
                    大多数企业需要的，是对问题理解的能力。
                    对问题理解的能力
            --- linear模型
                二叉堆
                    idea:
                        是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：
                            父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。
                            当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”
                        二项树
                            仅仅是树，不一定是满足堆的性质
                    c++imp:
                二项堆
                    idea:
                        不是数组。也不是树。二项队列的真身是一个小数组+若干棵树。
                        二项队列怎么Merge？
                        https://zhuanlan.zhihu.com/p/72854813
                        二项队列的合并有点像二进制数加法： [公式] ，某一位满了就进位。
                        Insert的最坏情形运行时间 [公式] 。
                        DeleteMin最坏情形运行时间 [公式] 。
                        https://pic1.zhimg.com/80/v2-6a9a9782688fd35b11bd8d9bc38b2864_1440w.jpg
                        简单来说，就是计算某个操作的平均代价，而不是只去关注最坏情形。
                        这倒霉的运行时间宛如“滴酒入池水”，被无限稀释。
                        先想像一下最好情形：将一个新元素插入到大小为偶数的二项队列，由于该队列 [公式] 为NULL，所以
                            直接将新元素作为 [公式] 。插入结束，运行时间 [公式] ，舒服了！
                        所以最好情形和最坏情形出现概率相同吗？很显然不相同。偶数出现概率为 [公式] ，而 [公式] 出现概率极低。
                        q- 依然可以计算！假定总插入次数为N 
                        https://zhuanlan.zhihu.com/p/72854813
                    c++imp:
                懒惰二项队列(lazy binomial queue)
                    idea:
                    c++imp:              
                斐波那契堆
                    idea:
                        https://zhuanlan.zhihu.com/p/75014494
                        其实是森林？
                        也是一种可合并堆
                        它比二项堆具有更好的平摊分析性能
                        斐波那契堆是一系列无序树的集合，每棵树是一个最小堆
                        堆保存了堆中所有节点的数目，保存了最小关键字的节点(这是整个堆的唯一入口
                        https://zh.wikipedia.org/wiki/%E7%BE%85%E4%BC%AF%E7%89%B9%C2%B7%E5%A1%94%E6%8F%9A
                        Robert Endre Tarjan
                        他发现了解决最近公共祖先（LCA）问题、强连通分量问题、双连通分量问题的高效算法，参与了开发斐波那契堆、伸展树的工作。
                        们发现斐波那契数列中暗含着黄金比例。
                        即随着n的增大
                        斐波那契数列的增长速度是指数级的，可以用归纳法简单的证明
                        lemma-数在斐波那契数列上的位置下标不大于其数值关于 [公式] 的对数
                        20世纪80年代，随着算法和数据结构的发展，图论算法被大规模使用，某些图算法需要频繁的减小每个边的权重
                        比如堆和二项堆，在DECREASE-KEY（减小某个元素的值）这个操作的复杂度为 [公式]
                        从程序员的角度，乙的做法降低了复杂度，又并没有影响程序的准确性。
                        森林里每棵树（n叉堆，n大小不限），都被一个双向链表（根链表）连在一起，
                            如图1。这样就实现了复杂度为O(1)的insert和merge。
                        EXTRACT-MIN和DECREASE-KEY需要做一些特殊的操作，保证每个根节点的度为 [公式] 
                        *只要让堆的节点总数对应斐波那契数，让节点的度对应斐波那契数列上的位置下标，斐波那契堆的雏形就诞生了。
                        每一棵树都是前两棵树拼在一起得到的结果，红球表示来自 [公式] 的节点，绿球表示来自 [公式] 的节点
                        斐波那契堆的雏形就长这样。
                        https://pic4.zhimg.com/80/v2-7e03f1956a153d18579ed89d891358af_1440w.jpg
                    c++imp:            
                *list vs vector 
                    Random Access, Insertion and Deletion
                    no random access in list possible
                双端队列
                    idea:
                    c++imp:
                **单链表 
                    idea:
                        construct
                            Node: prev, val, next
                            insert(Node* n)
                        创建链表时，我们不需要知道链表的长度
                        所以它没有闲置的内存，比起数组，空间效率更高。
                        链表的末尾添加一个结点
                        java完全放弃了指针
                        像是C/C++的程序依然运行在世界上大部分的机器上
                        如果我们想要在链表中查找某个元素，我们就只能从头结点开始，而不能像数组那样根据索引来，所以时间效率为O(N)
                        某值的结点并删除该结点
                        输入一个链表的头结点，从尾到头反过来打印出每个结点的值。
                        而递归在本质上就是一个栈，所以我们完全可以用递归来实现
                        但使用递归就意味着可能发生栈溢出的风险，尤其是链表非常长的时候。所以，基于循环实现的栈的鲁棒性要好一些。
                        利用栈来解决链表问题是非常常见的，因为单链表的特点是只能从头开始遍历，如果题目要求或者思路要求从尾结点开始遍历，那么我们就可以考虑使用栈，因为它符合栈元素的特点：先进后出
                        我们可以想想是否可以让两个指针的遍历动作同时进行呢？
                        我们可以先让一个指针从头指针开始行动，等到行动到第K - 1步的时候，我们再让第二个指针开始行动
                        不要一开始想到思路就开始写代码，最好是先想好测试用例，然后再让自己的代码通过所有的测试用例
                        输入两个链表，找出它们的第一个公共结点
                        公共结点，不仅要比较值，还要比较它下一个结点是否是一样
                        尾结点却要先比较，这种做法就是所谓的"后进先出"
                        给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点
                    stru-operation-pcode: &toimp
                        insert 
                        delete 
                        substitute 
                        search 
                        输入一个链表的头结点，从尾到头反过来打印出每个结点的值?
                        查找倒数第k个节点？
                        输入两个链表，找出它们的第一个公共结点？
                    c++imp:
                        ---https://blog.csdn.net/u010525694/article/details/78422657
                    例题         
                循环链表
                    idea:
                    c++imp:               
                *并查集
                    idea:
                        确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集
                        由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构
                        union-find data structure）或合并-查找集合（merge-find set）
                        问你整幅图一共有几个连通分支
                        如果是1个连通分支，说明整幅图上的点都连起来了，不用再修路了
                        如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，把它们连起来，
                            那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路
                        https://blog.csdn.net/Yaokai_AssultMaster/article/details/78888846 &toimp
                            算法目的：能够在如下条件下高效解决动态连接的问题
                            union find 至少有三种实现
                                no stl implementation!
                            Quick find用数组实现
                            pcode 
                                Union：欲将p和q相连，相当于合并包含p的联通集和包含q的联通集，
                                    也就是将所有id与id[p]相同的对象的id改为id[q]。
                                Find：检查p和q的id是否相同即可。
                            如果我们调用union(1,3)，则需要将所有id为2的对象的id改为4
                            pcode v1 
                                union:
                                    loop over all ele i 
                                        if id[i] == pid
                                            id[i] = qid 
                                find:
                                    return id[p] == id[q];
                            qq 这样实现的问题是什么？
                                find()操作的时间复杂度为O(1)。
                                union()操作的时间复杂度为O(N)。
                            直到有必要前，我们并不改变一个联通集中的每一个元素的id
                            Quick union的表现将随着我们不断调用union()构建联通集而
                                变差。因为代表这个联通集的树越来越高，调用getRoot()的开销也就越来越大
                            pcode v2
                                quickunion？
                            qq 复杂度？
                                find()操作的时间复杂度为O(n)。
                                union()操作的时间复杂度为O(1)。（其实也不是，还有getroot的复杂度）
                            qq 继续优化？
                                找出一些方法来使联通集所构造的树更加扁平。通过以下两种方法，我们可以大大减少树的高度。
                            LeetCode 200. 岛屿数量 是一道经典的面试题目，由于它涉及了 DFS、BFS、并查集等多种解法，成为一道不可多得好题目
                        https://zhuanlan.zhihu.com/p/134238834
                            Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。
                            Union：将两个子集合并成同一个集合
                            而 并查集 只是一种 数据结构，当我们和别人说“这道题属于并查集”的时候，实质上我们并没有谈到实际的解决方法。
                            只是在处理过程中符合树的特征
                            严格意义上讲，它们一个是数据结构，一个是算法，并不等同。
                            qq 判断一个无向图中是否存在环
                            pcode 判断一个无向图中是否存在环
                            find 函数用来寻找两个节点 A 和 B 的 祖先 是否是同一个节点，
                                如果是则说明它们属于一个集合，否则属于两个不同的集合
                            默认情况下所有点的祖先都是不同的，和他们的id相同
                        岛屿数量问题 &toimp
                            dfs and union-find 
                            pcode 
                                https://leetcode-cn.com/problems/number-of-islands/solution/200dao-yu-shu-liang-c-dfs-by-gao-yue-ran/
                                https://leetcode-cn.com/problems/number-of-islands/solution/c-dao-yu-shu-liang-bfs-by-iq91/
                            realc++
                                https://leetcode-cn.com/problems/number-of-islands/solution/200dao-yu-shu-liang-c-dfs-by-gao-yue-ran/
                                https://leetcode-cn.com/problems/number-of-islands/solution/c-dao-yu-shu-liang-bfs-by-iq91/
    
                    c++imp:                                   
                最大团
                    idea:
                    c++imp:
                最大独立集 
                    idea:
                    c++imp:
                *stack,queue
                    idea:
                        use stack/xx container classs, we have to include standerd header files 
                        do not forget std:: namespace !
                        do not forget template arguments 
                    例题 
                        ...
                    c++imp:              
                *multiset：多重集合，其实就是 set 集合的扩展版。
                    idea:
                        唯一的不同是 set 集合中一个值只能出现一次，
                            而多重集合中一个值可以出现多次。
                    c++imp:
                *hashmap 
                    idea:
                        hash算法的意义在于提供了一种快速存取数据的方法,它用一种算法建立键值与真实值之间的对应关系
                        key值,一般都是用某种算法(所谓的Hash算法)算出来的.例如:字符串的Hash算法, 
                        这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，    
                            而不可能从散列值来唯一的确定输入值
                        BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也是较为优秀的算法。 
                        LINK
                            https://blog.csdn.net/caoshangpa/article/details/78782378
                        哈希表(hash table)是从一个集合A到另一个集合B的映射(mapping)。
                        a被称为键值(key)，b被称为a的hash值(hash value)
                        A: 三位整数    hash(x) = x % 10    B: 一位整数
                        在git中，文件内容为键值，并用SHA算法作为hash function，将文件内容对应为固定长度的字符串(hash值)。
                        如果文件内容发生变化，那么所对应的字符串就会发生变化。git通过比较较短的hash值，就可以知道文件内容是否发生变动
                        为了安全起见，计算机不会直接保存该字符串，而是保存该字符串的hash值(使用MD5、SHA或者其他算法作为hash函数)
                        黑客闯入了数据库中的密码记录，他能看到的也只是密码的hash值。
                        很难从hash值去推测键值。因此，黑客无法获知用户的密码。
                        hash碰撞(hash collision)或者hash 冲突。比如网络协议中的checksum就可能出现这种状况
                        已经有实验表明，MD5算法有可能发生碰撞，也就是不同的明文密码生成相同的hash值，这将给系统带来很大的安全漏洞。
                            (参考hash collision）
                        复杂度直接降到O(1)。Hash表就能够达到这样的效果
                        存储位置只是表中的存储位置，并不是实际的物理地址)称作为Hash地址
                        则当想要找到“李四”的信息时，直接根据“李四”和Hash函数计算出Hash地址即可。
                        DETAIL 
                            假如对上述的联系人信息进行存储时，采用的Hash函数为：姓名的每个字的拼音开头大写字母的ASCII码之和。
                            首先，它浪费了大量的存储空间，空间利用率只有4/174，不到5%
                            另外，根据Hash函数计算结果之后，address(张三)和address(张帅)具有相同的地址，这种现象称作冲突
                            尽量考虑关键字的分布特点来设计函数使得Hash地址随机均匀地分布在整个地址空间当中。
                        *通常有以下几种构造Hash函数的方法，在数学上尽量保证平均  
                            根据特征
                                线性函数:取关键字或者关键字的某个线性函数为Hash地址，即address(key)=a*key+b;
                                平方取中法:对关键字进行平方运算，然后取结果的中间几位作为Hash地址。假如有以下关键字序列{421，
                                    423，436}，平方之后的结果为{177241，178929，190096}，那么可以取{72，89，00}作为Hash地址。
                                折叠：将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。假如知道
                                    图书的ISBN号为8903-241-23，可以将address(key)=89+03+24+12+3作为Hash地址。
                                分析数字：第一位，第二位，第三位重复的可能性大，取这三位造成冲突的机会增加，所以尽量不取前三位，取后三位比较好
                            普适方法
                                除留取余法：如果知道Hash表的最大长度为m，可以取不大于m的最大质数p，然后对关键字进行取余运算，address(key)=key%p。
                                    p选择的好的话，能够最大程度地减少冲突，p一般取不大于m的最大质数。
                                    典型的除留取余法Hash函数是time33算法。PHP的数组就是把这个作为哈希函数。
                                随机数：H(key)=random(key) ,其中random为随机函数。通常用于关键字长度不等时采用此法。
                        hash表大小要仔细确定
                            还有一种情况时可能事先不知道最终需要存储的记录个数，则需要动态维护Hash表的容量，此时可能需要重新计算Hash地址。
                        如果遇到冲突，哈希表一般是怎么解决的呢？具体方法有很多，百度也会有一堆，最常用的就是开放定址法和链地址法。
                            如果遇到冲突的时候怎么办呢？就找hash表剩下空余的空间，找到空余的空间然后插入。就像你去商店买东西，  
                                发现东西卖光了，怎么办呢？找下一家有东西卖的商家买呗。
                            有一个问题就是如果空间不足，那他无法处理冲突也无法插入数据，因此需要装填因子(空间/插入数据)>=1。
                                链地址法的原理时如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。
                                    我感觉业界上用的最多的就是链地址法。
                                当然也有最坏的情况就是hash值全都映射到同一个地址上，这样哈希表就会退化成链表
                                只要不要把hash计算的公式外漏出去并且有人故意攻击（用兴趣的人可以搜一下基于哈希冲突的拒绝服务攻击）
                                    ，一般也不会出现这种情况。
                        要本着易于编码调试的原则，个人认为BKDRHash是最适合记忆和使用的
                            https://blog.csdn.net/u012965373/article/details/38929637
                        example 
                            what i thought out :
                                电话号码本查询
                                    zhangsan 13980593357,20
                                    lisi 15828662334,18
                                    wangwu 13409821234,16
                                    zhangshuai 13890583472,30...
                                    ..
                                store name search (kaggle )
                                    https://www.kaggle.com/starbucks/store-locations/downloads/store-locations.zip/1
                            poj
                                poj3349:
                                    //判断是否有相同的雪花，顺序无关。数字是每一个花瓣的长度
                                        io
                                            2
                                            1 2 3 4 5 6
                                            4 3 2 1 6 5
                                            Twin snowflakes found. or No two snowflakes are alike.
                                        solution
                                            https://blog.csdn.net/lvshubao1314/article/details/42320263
                                            https://blog.csdn.net/hopeztm/article/details/7832750
                                poj3690:
                                    //字符矩阵匹配,找到相应的子矩阵
                                        io
                                            3 3 2 2 2
                                            *00
                                            0**
                                            *00

                                            **
                                            00

                                            *0
                                            **
                                            3 3 2 2 2
                                *00
                                0**
                                *00

                                **
                                00

                                *0
                                0*
                                0 0 0 0 0

                                Case 1: 1
                                Case 2: 2
                            solution 
                                https://blog.csdn.net/u011026968/article/details/38495821
                    c++imp:                    
                广义链表
                    idea:
                        对于线性表而言，n个元素都是基本的单元素，而在广义表中，这些元素不仅可以是单元素，
                            也可以是另一个广义表。通俗的讲，在广义表中的元素，也可以是一个线性表。
                    c++imp:
                跳舞链
                    idea:
                    c++imp:
                ***双指针，滑动窗口
                    idea:
                        https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/shuang-zhi-zhen-ji-qiao                    
                            双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」
                            qq hasCycle判定链表中是否含有环
                                如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。
                            qq 已知链表中含有环，返回这个环的起始位置
                                当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，
                                再次相遇时所在的节点位置就是环开始的位置
                                第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步
                                k 步（也就是环的长度）。
                                只要我们把快慢指针中的任一个重新指向 head
                                然后两个指针同速前进
                            qq 寻找链表的中点
                                类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，
                                    当快指针到达链表尽头时，慢指针就处于链表的中间位置。
                            返回倒数第k和倒数第k-4个数在链表中（n指针策略）
                                当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右
                            对于链表，合并两个有序链表是很简单的，难点就在于二分。
                            但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序
                            qq 寻找链表的倒数第 k 个元素
                                k 步，然后快慢指针开始同速前进
                            这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点
                            左右指针在数组中
                            前文「二分查找」有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性
                            只要数组有序，就应该想到双指针技巧
                            反转数组
                            *「滑动窗口」也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类
                                子字符串匹配的问题
                            不过「滑动窗口」稍微比上述的这些算法复杂些
                            子串匹配
                            * 双指针的快慢指针和左右指针的用法
                            * 总结出一套框架，可以保你闭着眼睛都能写出正确的解法。
                            * LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难
                            这两个 ... 处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。
                            只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末
                            labuladong 公众号的重点在于算法思想，你把框架思维了然于心，然后随你魔改代码好吧，你高兴就好
                            下面就直接上四道 LeetCode 原题来套这个框架，其中第一道题会详细说明其原理，后面四道就直接闭眼睛秒杀了
                        
                        https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hua-dong-chuang-kou-ji-qiao-jin-jie
                            可以使用方括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，
                                C++ 会自动创建这个 key，并把 map[key] 赋值为 0
                            最小覆盖子串
                        
                        https://juejin.im/post/5c74a2e2f265da2dea053355
                            Sliding windowing算法
                            滑动窗口经常作为一个抽象的概念来处理数组/字符串问题。
                            窗口代表着一组数据/字符串元素
                            通过开头和结尾的索引来定义窗口
                            qq 没有重复字符的子字符的最大长度：给一个字符串，获得没有重复字符的最长子字符的长度
                                输入："abcabcbb"  输出：3
                            pcode x3
                                ...
                            时间复杂度：O(2n)。在最差的情况下，每个字符将会被访问两次
                            上面的滑动窗口算法最多需要2n的步骤，但这其实是能被优化为只需要n步
                            * 滑动窗口算法可以将嵌套的for循环问题，转换为单循环问题，降低时间复杂度
                    c++imp:
                ...
            --- tree模型 
                *construct
                    Node: val, left, right 
                    buildTree(Node*& root)
                *优先队列
                    idea:
                    c++imp:
                *BST 二叉查找树 Binary Search Tree 
                    idea:
                        https://blog.csdn.net/John_xyz/article/details/79622219
                            二叉查找树（Binary Search Tree），也称二叉搜索树、有序二叉树（ordered binary tree），排序二叉树（orted binary tree），
                            若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；  若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；  任意节点的左、右子树也分别为二叉查找树；
                            没有键值相等的节点
                            二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低,均为O(log n)。
                            二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。
                            插入
                                若b是空树，则将s所指结点作为根节点插入
                                新插入节点总是叶子节点
                            删除
                                如果待删除的节点是叶子节点，那么可以立即被删除
                                如果有一个子节点，要将下一个子节点上移到当前节点，即替换之
                                如果有两个子节点，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除
                            遍历
                                用中序遍历来实现，可以保证按从小到大的顺序打印。
                                用一组数值建造一棵二叉查找树的同时，也把这组数值进行了排序
                                若该组数值经是有序的（从小到大），则建造出来的二叉查找树的所有节点，都没有左子树
                            查找：最佳情况Olog(n), 最坏情况O(n)  插入：最佳情况Olog(n), 最坏情况O(n)  删除：最佳情况Olog(n), 最坏情况O(n)
                            
                        https://andrewpqc.github.io/2018/01/07/binary-search-tree/
                            一个无序序列可以透过建构一棵二叉查找树变成一个有序序列
                            在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可
                            搜索、插入、删除的复杂度等于树高，期望{\displaystyle O(\log n)}O(\log n)，最坏{\displaystyle O(n)}O(n)（数列有序，树退化成线性表）。
                            qq 什么是满二叉树,完全二叉树？
                            https://zhuanlan.zhihu.com/p/29867652
                            叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部
                            在实际应用中，二叉查找树的使用比较多
                            随机化的构造树的方式也不能完全杜绝最坏情况的出现，所以还有一些二叉搜索树的变种，
                                如红黑树，B树等，他们可以保证基本操作具有好的最坏情况性能。
                            qq 举例说明为啥会退化，什么是退化的情形
                            比如要找具有最小关键字的节点，我们可以从根节点一直向左查找，
                                如果一个节点具有左孩子，那么它的左孩子的关键字一定比它本身的关键字小，
                                这时就可以迭代的去查看其左孩子
                            找最大值,一直向右找，直到找到最右边的一个节点
                            qq 如何找最小最大值？
                            qq 查找前驱与后继?
                                找节点a的后继节点就是找树中关键字比a的关键字大的所有节点中的最小关键字节点
                                前驱就是小于a的节点关键字中最大的哪一个
                                    如果存在右子树，那么则在右子树中查找最大的
                                    如果不存在，则回溯，找到第一个右子树回溯
                            读书人的东西怎么能叫偷呢:)
                            我们就要从a节点开始追根溯源，向上找它的祖先，直到找到第一个这样的祖先s:s的左孩子s’
                            找后继节点的代码
                            如果k小于当前节点的key，那么就需要到当前节点的左子树中
                            如果k大于当前节点的key，那么就需要到当前节点的右子树中去找
                            https://andrewpqc.github.io/2018/01/07/binary-search-tree/
                            第一个数组构造出来的二叉搜索树的每个节点只有右孩子没有左孩子，而第二个构造出来的二叉搜索树的每个节点则只有左孩子没有右孩子。这就是极其低效的二叉树。怎样去避免这样的问题呢？
                            {1,2,3,4,5},或者是这样的{9,8,6,4,3,2}，
                            可以在用户提供的数组中通过不重复无遗漏的随机取元素的方法来构造一个随机序列，然后用该序列来构造一个随机二叉搜索树
                            上述随机构建二叉搜索树的方法，在初始化构建树的时候，确实可以降低因用户给定的数组有序而创建低效二叉搜索树的情况，但是它无法做出保证。
                            前面的动态操作会降低后面操作的效率。怎么办呢?这就要看其他的一些二叉搜索树的变体了！
                    pcode: &toimp
                        插入
                            若b是空树，则将s所指结点作为根节点插入，否则：
                            若s.val等于b的根节点的数据域之值，则返回，否则：
                            若s.val小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：
                            把s所指节点插入到右子树中（新插入节点总是叶子节点）
                            ---

                        查找
                            若b是空树，则搜索失败，否则：
                            若x等于b的根节点的数据域之值，则查找成功；否则：
                            若x小于b的根节点的数据域之值，则递归搜索左子树；否则:
                            递归查找右子树
                        删除
                            如果待删除的节点是叶子节点，那么可以立即被删除
                            如果有一个子节点，要将下一个子节点上移到当前节点，即替换之
                            如果有两个子节点，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除
                        查找后继节点？
                            如果存在右子树，那么则在右子树中查找最小的
                            如果不存在，则回溯，找到第一个右子树回溯
                            ---
                            if node->right != NULL 
                                minimum(node->right)
                            else 
                                while loop to find the first precessor that p->right == node
                        查找前驱节点？
                            如果存在左子树，那么则在左子树中查找最大的
                            如果不存在，则回溯，找到第一个左子树回溯
                            ---
                            if node->left != NULL 
                                maximum(node->left)
                            else 
                                while loop to find the first precessor that p->left == node
                        最小值？
                            持续遍历左子树
                        最大值？
                            持续遍历右子树
                        随机构建算法？
                            select the array randomly 
                            insert to tree 
                            restore local var. 
                    c++imp:           
                AVL huge
                    idea:
                        https://zh.wikipedia.org/wiki/AVL%E6%A0%91
                            AVL树是最早被发明的自平衡二叉查找树
                            任一节点对应的两棵子树的最大高度差为1
                            因此它也被称为高度平衡树
                            最坏情况下的时间复杂度都是{\displaystyle O(\log {n})}O(\log{n})
                            增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡
                            AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，
                                他们在1962年的论文《An algorithm for the organization of information》
                                中公开了这一数据结构
                            qq 平衡因子是?
                                它的左子树的高度减去它的右子树的高度（有时相反）
                            带有平衡因子1、0或 -1的节点被认为是平衡的
                            qq 在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作??
                            https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png
                            因为在旋转成叶子节点期间最多有log n个节点被旋转，而每次AVL旋转耗费固定的时间，
                                所以删除处理在整体上耗费O(log n) 时间
                            因为AVL树总是保持平衡的。不需要特殊的准备，树的结构不会由于查找而改变
                            这是与伸展树搜索相对立的，它会因为搜索而变更树结构
                            qq 当节点数为N时，高度h最多为？
                        https://zhuanlan.zhihu.com/p/34899732
                            可见名字长的好处，命名都能多占一个字母出来
                            Adelson-Velskii 以及 Landis
                        https://www.jianshu.com/p/65c90aa1236d
                            AVL 树引入了所谓监督机制，就是在树的某一部分的不平衡度超过一个阈值后触发相应的平衡操作。
                            我们必然需要一个监督指标，以此来判断是否需要进行平衡操作。这个监督指标被称为“平衡因子（Balance Factor）”。
                            平衡因子： 某个结点的左子树的高度减去右子树的高度得到的差值。
                            AVL 树： 所有结点的平衡因子的绝对值都不超过 1 的二叉树
                            引入了高度属性的 AVL 树的节点定义
                            借由树的递归定义，我们很容易写出这一函数。
                            return max(treeHeight(root->left),treeHeight(root->right)) + 1
                            在插入结点时， 沿插入的路径更新结点的高度值
                            更新受影响的所有节点的高度
                            在删除结点时（delete）,沿删除的路径更新结点的高度值  
                            treeGetBalanceFactor
                            计算平衡因子的操作
                            再平衡操作
                            右旋操作，就是把上图中的 B 节点和 C 节点进行所谓“父子交换”。
                            从根节点(root)开始到某一个叶子节点(leaf)的最长路径(path)上结点的个数
                            高度(height)
                            在AVL树中搜索和在BST中的搜索是完全一样的
                            获取树中所有结点的有序集合
                                直接中序遍历
                    pcode: &toimp later huge
                        rightRotation:
                        leftRotation:
                        rebalanced:
                        insert:
                        Delete:
                        search:
                            similar to basic BST 
                    c++imp:
                        ---https://gist.github.com/laihaotao/319b7045c0a60c2c2651ae97ceecc536
                红黑 huge
                    idea:
                        面试旧敌之红黑树
                        qq 在10亿数据进行不到30次比较就能查找到目标时，不禁感叹编程之魅力！人类之伟大呀！
                        qq 红黑树怎么自平衡
                        红黑树之所以难是难在它是自平衡的二叉查找树
                        在进行插入和删除等可能会破坏树的平衡的操作时，需要重新自处理达到平衡状态
                        qq 红黑树性质
                            性质1：每个节点要么是黑色，要么是红色。  
                            性质2：根节点是黑色。  
                            性质3：每个叶子 节点（NIL）是黑色。  性质4：每个红色结点的两个子结点一定都是黑色。
                            任意一结点到每个叶子结点的路径都包含数量相同的黑结点。
                        在Java中，叶子结点是为null的结点。
                        根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任
                            意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑
                            树这种平衡为黑色完美平衡。
                        qq 什么是黑色完美平衡。
                        qq 红黑树能自平衡，它靠的是什么？
                            三种操作：左旋、右旋和变色。
                        上面所说的旋转结点也即旋转的支点，
                        左旋只影响旋转结点和其右子树的结构
                        qq 旋转操作是局部的?本质是什么？
                            当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么
                                向另外一边子树“租”一些结点。
                        还得靠变色了。怎么变？具体情景又不同变法，后面会具体讲到，现在只需要记住红黑树总
                            是通过旋转和变色达到自平衡
                        
                    c++imp:
                伸展树 huge
                    idea:
                        在均摊{\displaystyle O(\log n)}O(\log n)的时间内完成基于伸展（Splay）操作
                            的插入、查找、修改和删除操作
                        Robert Endre Tarjan
                        罗伯特·恩卓·塔扬（英语：Robert Endre Tarjan，1948年4月30日－）
                        他发现了解决最近公共祖先（LCA）问题、强连通分量问题、双连通分量问题的高效算法，参与了开发斐波那契堆、伸展树的工作。不少他发明的算法都以他的名字命名，以至于有时会让人混淆几种不同的算法。
                        Association for Computing Machinery
                        为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。
                        它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。
                        优势在于不需要记录用于平衡树的冗余信息
                        最近访问的节点都会离根节点更近，且伸展树也会大致平衡
                        共有三种旋转操作，每种都有左旋（Zig）和右旋（Zag）两种情况
                        每次旋转操作由三个因素决定
                        * 似乎是更加复杂的旋转
                *trie树 
                    idea:
                    c++imp:   
                后缀树
                    idea:
                    c++imp:
                
                单词查找树
                    idea:
                    c++imp:
                堆 
                    idea:
                    c++imp:
                
                van Emde 树 
                    idea:
                    c++imp:
                kd-树（搜索树）
                    idea:
                    c++imp: 
                BSP树 
                    idea:
                        线段树  
                    c++imp:
                博弈树  
                    idea:
                    c++imp:
                ida* algorithm
                    idea:
                    c++imp: 
                树状数组  
                    idea:
                    c++imp:
                左偏树  
                    idea:
                    c++imp:
                多串匹配树 
                    idea:
                    c++imp: 
                字典树 
                    idea:
                    c++imp:
                无根树  
                    idea:
                    c++imp:
                trie树(静态建树、动态建树)
                    idea:
                    c++imp:  
                B-树、B+树、B*树
                    idea:
                    c++imp:
                位置树
                    idea:
                    c++imp:
            --- graph模型 (not so many)
                构建--图型结构的四种存储结构
                    idea:
                        https://zhuanlan.zhihu.com/p/30343791
                        https://pic3.zhimg.com/80/v2-c444b84c2bcee24205771ec817f4926a_hd.jpg
                        无向图和有向图的存储结构是有区别的
                        * 数据结构其实只有两种，
                            线性表的顺序结构，和线性表的链式结构
                        +
                            邻接表存储是表示实际上意义的东西，邻接矩阵只是一种简化思路
                            线性链表--只有一个（或扩展成多个）链接域
                            树--有两（左右孩子）（或扩展成多个）个链接域
                            图--有无穷个边，链接域
                                这时候需要特殊处理：把边链式存储！：：邻接表存储法
                        *1.数组，邻接矩阵
                            利用两个数组分别存储顶点（vector）和边（edge）。 
                            顶点用一维数组
                            边用二维数组存储：一个矩阵，无向图的二维数组是关于对角线对称的
                        *2.邻接表存储
                            +
                                space effecient 
                            弧头和弧尾都是指顶点，在G1中，对于Ea来说V1是弧头，V2是弧尾
                            其实就利用一个一维数组存储链表
                            数组数据类型：
                                data域：存储顶点（Vi）的数据信息。 
                                firstarc域：顾名思义就是该域指向与顶点（Vi）相连的第一条弧（arc）,
                                    这里指的第一条并没有特定的顺序，只是为了和之后的弧进行区分而出现的概念。
                            表节点中有三个域
                                adjvex，next, info
                            无向图的度就是链表中表节点的个数
                            有向图的度
                                以（Vi）顶点为头结点的链表后面接着的表节点中是以顶点（Vi）为弧头的弧
                                要有向图的度还要求出有向图的入度，邻接表中的adjvex域值为i的表节点的
                                    个数是顶点（Vi）的入度。
                                为了方便求有向图的入度我们引入了逆邻接表
                            +逆邻接表
                        2->十字链表法
                            所谓的十字链表法就是结合了邻接表和逆邻接表，以方便求出图形结构的出度和入度
                            邻接表的改进
                        1->邻接多重表
                            邻接多重表是针对于无向图改进的存储结构
                            这对我们对边进行操作的时候十分不便，假设我要删除一条边，
                                那么我要在两条链表中去删除这条边两次，这增加了我们程序的复杂度
                            让一条边仅仅用一个节点表示
                            一条边由一个节点六个域表示
                                ivex和jvex域：这两个域中存储的是顶点的位置,因为一条边连接两个顶点
                                ilink和jlink域：这两个域中存放的是边的位置，ilink中存储顶点Vi的下一条边的位置。 
                                info域：可以用来存储边的权值。 
                                头结点
                        https://www.geeksforgeeks.org/graph-and-its-representations/
                    c++imp:
                        Node: val,vector<Node*> adjnodes;
                        addEdge(Node* m, Node* n)
                dag graph
                    idea:
                        有向无环概率图模型(Directed Acyclic Graphs, 简称DAG)
                    c++imp:
                八叉树
                    idea:
                    c++imp:
                ...  
        * 算法与思想new
            //
                在熟悉结构的基础上解决问题
                雄关漫道真如铁，而今迈步从头越
                https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bei-bao-wen-ti
                * 难的伪代码肯定是要背的，简单的很容易推导
                    最好是图像化背诵，比如二分那个！汉诺塔？
                    脑子里复现，尝试去描述！ 
                如果是面试的话其实背的用途也不大，如果你能给面试
                    官系统地解释你对这个算法的理解其实重要得多。
                背算法其实和背代码是不一样的。算法基本上只是描述了运算执行的过程，是种很模糊的东西
                有的算法太过复杂，也容易背错，还不如现场推导
                另外还有一个特别有效的方法：把思路讲出来。看懂代码之后，把这道题的思路自己讲出来
                https://www.zhihu.com/question/30501748
                设置基准，即递归终止条件
                主要有两种关系：顺序关系和链式关系
                    定义tree：用链式关系
                    定义graph：用链式关系+顺序关系
            --- linear 
                *数论算法
                    整数问题
                        组合数学
                            普通涂色问题 组合数学-Polya定理
                            约瑟夫问题
                            卡特兰数是组合数学中一个常出现在各种计数问题中的数列
                        数论问题：
                            辗转相除（两行内）
                            任意进制间的转换
                            大整数的分解
                            求素数
                                https://www.zhihu.com/question/307930531/answer/566185328
                            最大公约数(Gcd)两种算法(Euclid && Stein) 
                        数字游戏
                        博弈类
                    精度
                        提高精度
                            高精度四则运算
                            高精度pi计算
                                使用
                    高阶问题
                        矩阵快速乘法
                        快速傅里叶变换
                        fibonacci数列 &
                            用数组，可以在linear 时间中完成
                            很多数列问题都可以
                        解线性方程组
                            +在图形学中应用广泛，CV中，ML中
                            例如mesh parameterization
                            最小化能量方程
                            -
                        解线性规划问题
                            单纯形算法
                    交换
                        idea： 存取，先把第一个数存起来，而后取用
                *比特位操作
                *排序x11
                    https://www.cnblogs.com/onepixel/articles/7674659.html
                    冒泡
                        idea: 
                            依次比较相邻的数据，将小数据放在前，大数据放在后
                            一次排序出来一个最大的（外层循环） 
                        pcode:
                                loop all sorted i 
                                    loop all unsorted j 
                                        if not consistant 
                                            swap 
                            ---
                                loop, i sorted from 0 to max:  
                                    loop all unsorted from 0 to max - i: 
                                        compare two ele. if not sorted
                                            swap
                                        else 
                                            nothing happens
                        io:
                            int a[] = {9,0,6,5,8,2,1,7,4,3};
                            0 1 2 3 4 5 6 7 8 9
                        realc++:
                            void sort(int* a, int size) {
                                // loop sorted items i from 0 to max:
                                for (int i = 0; i < size; i++) {
                                    // loop unsorted items j:
                                    for (int j = 0; j < size - i; j++) {
                                        // if two ele. unsorted, swap:
                                        if (a[j] > a[j + 1]) {
                                            // swap
                                            int tmp;
                                            tmp = a[j];
                                            a[j] = a[j + 1];
                                            a[j + 1] = tmp;
                                        }
                                    }
                                }
                            }
                    选择排序Selection Sort
                        idea: 
                            在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
                                然后，再从剩余未排序元素中继续寻找最小（大）元素，
                                然后放到已排序序列的末尾
                            选择极值，而后插入
                            相比于选择排序，插入排序的一个优点是提前终止，不用遍历整个数组
                        pcode:
                            loop all position
                                loop to select the min value 
                                put it to the current position 
                        io: 
                            the same 
                        realc++: 
                            void selection_sort(int* a, int size) {
                                // loop all position 
                                for (int i = 0; i < size; i++) {
                                    int minval_posi = i;
                                    // select the min val in unsorted position
                                    for (int j = i + 1; j < size; j++) {
                                        if (a[j] < a[minval_posi])
                                            minval_posi = j;
                                    }
                                    // put it to the desired position 
                                    int tmp = a[i];
                                    a[i] = a[minval_posi];
                                    a[minval_posi] = tmp;
                                }
                            }
                    * 插入排序InsertionSort 
                        idea: 
                            从第一个元素开始，该元素可以认为已经被排序；
                            取出下一个元素，在已经排序的元素序列中从后向前扫描；
                            如果该元素（已排序）大于新元素，将该元素移到下一位置；
                            重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
                            将新元素插入到该位置后；
                            重复步骤2~5。
                        pcode:
                            loop all unsorted 
                                backward loop, while not a suitable position:
                                    move the sorted backward 
                                insert 
                        io: 
                            the same 
                        realc++: 
                            void insertion_sort(int* a, int size) {
                                // loop all unsorted positions 
                                for (int i = 1; i < size; i++) {
                                    // mark the current one 
                                    int current = a[i];
                                    int preindex = i - 1;
                                    // backward loop all sorted posi. and find a suitable one 
                                    for (int j = i - 1; j >= 0; j--) {
                                        // if not suitable, move the sorted ones backward 
                                        if (a[j] > current) {
                                            a[j + 1] = a[j];
                                            preindex--;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                    // insert 
                                    a[preindex + 1] = current;
                                }
                            }
                    归并排序
                        idea: 
                            建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用
                            将已有序的子序列合并，得到完全有序的序列
                        pcode:
                            Divide recursevely
                            (condition: n<2)
                                merge after left and right subarray sorted 
                                (assign value to A iteratively)
                        io: 
                            the same 
                        realc++: 
                            void merge(int* a, int* L, int lsize, int* R, int rsize) {
                                // merge sorted subarray 
                                int i = 0;
                                int j = 0;
                                int k = 0;
                                while (i < lsize && j < rsize) {
                                    if (L[i] < R[j])
                                        a[k++] = L[i++];
                                    else
                                        a[k++] = R[j++];
                                }
                                while (i < lsize)
                                    a[k++] = L[i++];
                                while (j < rsize)
                                    a[k++] = R[j++];
                            }
                            void merge_sort_recur(int* a, int size) {
                                // devide recursively, stop at n<2 
                                if (size < 2) return;
                                int mid = size / 2;
                                int* L = new int[mid];
                                int* R = new int[size - mid];
                                for (int i = 0; i < mid; i++) {
                                    L[i] = a[i];
                                }
                                for (int i = mid; i < size; i++) {
                                    R[i - mid] = a[i];
                                }
                                merge_sort_recur(L, mid);
                                merge_sort_recur(R, size - mid);
                                merge(a, L, mid, R, size - mid);
                                delete[] R;
                                delete[] L;
                            }
                    希尔排序shell sort 
                        idea:
                            希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更
                            高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一
                            利用了以下事实：
                                * 直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的
                            上面希尔排序的步长选择都是从n/2开始，每次再减半，直到最后为1。其实也可以有另外的更高效的步长选择
                            增量gap，并逐步缩小增量
                            和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行
                            preIndex 变成了 j - gap
                            preIndex--; --> j = j - gap 
                        pcode:
                            start from some gap and decrease it until zero 
                                (insertion sort in each group)
                                loop all unsorted 
                                    backward loop, while not a suitable position:
                                        move ele. backward 
                                    insert 
                        io: 
                            the same 
                        realc++:  
                            void shell_sort(int* a, int size) {
                                // start from some gap and decrease until 0 
                                for (int gap = floor(size / 2); gap > 0; gap = floor(gap / 2)) {
                                    // loop all unsorted position 
                                    for (int j = gap; j < size; j++) {
                                        int preidx = j - gap;
                                        int current = a[j];
                                        // backward loop sorted position, while not suitable:
                                        while (preidx >= 0 && a[preidx] > current) {
                                            // move the elements backward 
                                            a[preidx + gap] = a[preidx];
                                            preidx = preidx - gap;
                                        }
                                        // insert 
                                        a[preidx + gap] = current;
                                    }
                                }
                            }  
                    stl sort
                        idea: 
                            make use of sort function in algorithm header 
                            this function has a parameter of vector 
                        pcode:
                        io: 
                        realc++:  
                            #include <algorithm>
                            #include <vector>
                            void stl_vector_sort(int* a, int size) {
                                vector<int> v;
                                for (int i = 0; i < size; i++) {
                                    v.push_back(a[i]);
                                }
                                sort(v.begin(),v.end());
                                for (int i = 0; i < size; i++) {
                                    a[i] = v.at(i);
                                }
                            }
                    快速排序（Quick Sort）
                        idea: 
                        pcode:
                        io: 
                        realc++: 
                    堆排序（Heap Sort）
                        idea: 
                        pcode:
                        io: 
                        realc++: 
                    计数排序（Counting Sort）
                        idea: 
                        pcode:
                        io: 
                        realc++: 
                    桶排序（Bucket Sort）
                        idea: 
                        pcode:
                        io: 
                        realc++: 
                    基数排序（Radix Sort）
                        idea: 
                        pcode:
                        io: 
                        realc++: 
                *串处理算法
                    Rabin-Karp算法
                    KMP算法
                        KMP算法俗称“看(K)毛(M)片(P)算法”
                        KMP算法是比较难以理解的算法，但是不繁琐，而是很精妙，值得理解
                    最长上升子序列(Longest Increasing Subsequence)问题
                    最长公共子序列LCS问题					
                    最大子序列 &
                        这个问题之所以有吸引力，主要是因为存在求解它的很多算法，而这些算法的性能差异又很大
                        非常典型的算法优化问题，有多种复杂度实现版本
                        max sum value in subsequence :
                        1.loop twice:
                            a b c d e f ...
                                ...
                            the ,maximum computational complex is : O(N^2)
                            this is what who havent leared algorithm has wroten
                            pcode：
                                loop outlier array from start to end 
                                    loop from i to end 
                                        check if larger than max 
                        2.using DP algorithm 
                            can run to Nlog(N)
                            this can be applied to other applications 
                            pcode:
                                分三种情况进行递归，选择最小的
                        3.using some mathematical tricks :
                            can be O(N)
                            maybe cannot be applied to others 
                            pcode:
                                loop the array 
                                    if current sum is lower than 0
                                        reset max to next value 
                                    else
                                        add next value
                    levenstein距离
                        最后用了dp的思想解决
                    Boyer-Moore字符串查找算法
                    Rabin-Karp指纹字符串查找算法           
                *动态规划
                    +
                        四边形不等式理论
                        状态DP
                    这些技巧无法举一反三，学了也不划算
                    //思路很简单都是拉表格，主要还是写公式
                    https://www.zhihu.com/question/20686504
                    基本背包，基本优化
                        idea: 
                            * 其实就是遍历个表，如果不要求中间结果的话可以优化空间
                            确定性问题版本的背包问题是NP的
                            对其加上不同的限制和条件，可以衍生出诸多变种，若要全面理解动态规划，就必须对背包问题了如指掌
                            https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bei-bao-wen-ti
                            刷题刷多了就会发现，算法技巧就那几个套路
                            动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法
                            动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算
                            动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值
                            虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其
                                实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举
                            重叠子问题、最优子结构、状态转移方程
                            在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因
                            https://zhuanlan.zhihu.com/p/85780471
                            * 可以采用动态规划常用的方法（滚动数组）对空间进行优化（即去掉dp的第一维）
                            pp 地推公式后面为啥i-1
                            从第一行开始，从左往右开始填表，可以发现除了第一行外，每一行都只和它的上一行有关
                            pp 还可以从右往左开始填表??
                                是背包问题的特殊性决定的，仅仅取决于上一行对应位置
                            永远只保存一行数
                                最后得到的事最后一行的数值
                                但是计算时间没有优化，只是空间优化了
                                有时题目会要求我们输出最优解，而不只是最优解的答案，这时我们就无法在空间上对算
                                    法进行优化了，因为我们需要每一次变化中保存的值，以回溯最优解
                            回溯最优解？
                                从结尾开始遍历所有行就ok，复杂度和物品个数n线性相关 
                        pcode:
                            //
                                fill numbers to the corner cases 
                                iterate the table and computing based on the function 
                                backtrack to get the object to pick  

                            //
                                loop all lines 
                                fill the line from right side 
                        io: (standard result for checking)
                            N M 
                            wi vi 
                            ...

                            4 6
                            1 4
                            2 6
                            3 12
                            2 7

                            23 
                            ---

                            5 11 
                            1 1
                            2 6
                            5 18
                            6 22 
                            7 28

                            40
                            ---

                            https://pic1.zhimg.com/v2-861a4291fcbfa52c8c2fece808134399_1440w.jpg
                        realc++: 
                            #include<iostream>
                            #include<vector>
                            #include <algorithm>
                            using namespace std;
                            int main() {
                                int N, M;
                                int* w = new int[1024];
                                int* v = new int[1024];
                                cin >> N >> M;
                                for (int i = 0; i < N ; i++) {
                                    cin >> w[i] >> v[i];
                                }
                                vector<vector<int>> f(N, vector<int>(M + 1));
                                /*for (int i = 0; i < N; i++) {
                                    for (int j = 0; j < M + 1; j++) {
                                        f[i][j] = 0;
                                    }
                                }*/
                                // fill the corner case 
                                for (int i = 0; i < N; i++)
                                    f[i][0] = 0;
                                for (int j = 1; j < M + 1; j++) {
                                    if (j >= w[0])
                                        f[0][j] = v[0];
                                    else 
                                        f[0][j] = 0;
                                }
                                // iterate the table 
                                for (int i = 1; i < N; i++) {
                                    for (int j = 1; j < M + 1; j++) {
                                        if (j < w[i]) {
                                            f[i][j] = f[i - 1][j];
                                        }
                                        else {
                                            f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]);
                                        }
                                    }
                                }
                                // show table 
                                for (int i = 0; i < N; i++) {
                                    for (int j = 0; j < M + 1; j++) {
                                        cout << f[i][j] << "\t";
                                    }cout << "\n";
                                }
                                // backtrace
                                int i = N - 1;
                                int j = M;
                                cout << "which to pick? :" << endl;
                                while (i > 0) {
                                    if (f[i][j] == f[i - 1][j]) {
                                        cout << "not pick "<< i << endl;
                                    }
                                    else if(f[i][j] == f[i - 1][j - w[i]] + v[i] ){
                                        cout << "pick " << i << endl;
                                        j-= w[i];
                                    }
                                    i--;
                                }
                                if (f[i][j] > 0) {
                                    cout << "pick " << i << endl;
                                }
                                else {
                                    cout << "not pick " << i << endl;
                                }
                            }
                    poj3624
                        realc++:
                            #include <cstdio>
                            #include <cstdlib>
                            #include <iostream>
                            #include <cstring>
                            using namespace std;
                            int bag[12900];
                            int w[3410], v[3410];
                            int main(void)
                            {
                                int n, m;
                                while (cin >> n >> m)
                                {
                                    for (int i = 1; i <= n; i++)
                                        cin >> w[i] >> v[i];
                                    memset(bag, 0, sizeof(bag));
                                    for (int i = 1; i <= n; i++)
                                        for (int k = m; k >= w[i]; k--)
                                            if (bag[k - w[i]] + v[i] > bag[k])
                                                bag[k] = bag[k - w[i]] + v[i];
                                    cout << bag[m] << endl;
                                }
                                return 0;
                            }
                    LeetCode 416  &toimp 
                        description:
                            Given a non-empty array containing only positive integers, 
                            find if the array can be partitioned into two subsets 
                            such that the sum of elements in both subsets is equal.
                        io:
                            Input: [1, 5, 11, 5]
                            Output: true
                            Explanation: The array can be partitioned as [1, 5, 5] and [11].
                        pcode:
                        io: 
                        realc++: 
                    莱文斯坦距离  &toimp
                        idea: 
                            莱文斯坦距离有几个简单的上下界
                                至少总是两个字符串大小的差值
                                至多是较长字符串的长度
                                当且仅当两个字符串相等时值为0
                                如果两个字符串大小相等，汉明距离是其上界
                                两个字符串的莱文斯坦距离不大于分别与第三个字符串的莱文斯坦距离之和（三角不等式）
                            可以用于字符串近似匹配
                            ext 
                                Damerau–莱文斯坦距离（Damerau–Levenshtein distance）允许插入、删除、替换和交换两个相邻字符；
                                最长公共子序列（ longest common subsequence）只允许插入和删除操作；
                                汉明距离（Hamming distance）只允许替换操作，因此只适用于两个相等长度的字符串。
                            分别对应删除插入替换！！！ 
                            &q formula! https://www.zhihu.com/equation?tex=%5Coperatorname%7Blev%7D_%7Ba%2C+b%7D%28i%2C+j%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D%7B%5Cmax+%28i%2C+j%29%7D+%26+%7B%5Ctext+%7B+if+%7D+%5Cmin+%28i%2C+j%29%3D0%7D+%5C%5C+%7B%5Cmin+%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D%7B%5Coperatorname%7Blev%7D_%7Ba%2C+b%7D%28i-1%2C+j%29%2B1%7D+%5C%5C+%7B%5Coperatorname%7Blev%7D_%7Ba%2C+b%7D%28i%2C+j-1%29%2B1%7D++%5C%5C%7B%5Coperatorname%7Blev%7D_%7Ba%2C+b%7D%28i-1%2C+j-1%29%2B1_%7B%5Cleft%28a_%7Bi%7D+%5Cneq+b_%7Bj%7D%5Cright%29%7D%7D+%5Cend%7Barray%7D%5Cright.%7D+%26+%7B%5Ctext+%7B+otherwise+%7D%7D%5Cend%7Barray%7D%5Cright.

                        pcode:(with line number )
                            1.fill the corner case 
                            2.loop over the table and calculate each cell 
                            3.backtrace 
                        io: 
                            ---
                                string a = "love" 
                                string b = "olve" 

                                1 
                            ---
                                string a = "love" 
                                string b = "lolpe" 

                                2
                            ---
                                a='love',b='sffg',c='lovefghaa'

                                lev(a,b)=4,lev(a,c)=5
                        realc++:  
                *分治
                    经典问题
                        二分搜索
                        最大子段和 &toimp
                            https://blog.csdn.net/YE1215172385/article/details/79862326
                            idea: 
                                分别求左右子序列的和，与自身比较，结果是三者最大的
                                左边包含边界最大序列和，是连续的但是未必包含哪几个数
                                右边包含边界最大序列和
                                其实是横跨中间的
                                &t 证明算法复杂度！！！
                                https://blog.csdn.net/weixin_40170902/article/details/80585218
                                递归算法的基本准则：
                                    (1) 基准情形：存在最小子问题的解，也称为递归终止的条件。
                                    (2) 不断推进：每一次递归调用都要使得求解状况不断地朝基准情形方向推进。
                                    (3) 设计法则：* 假设 所有递归调用都能运行。
                                    (4) 合成效益法则：在求解一个问题的同一实例式，
                                        要避免在不同的递归调用中做重复的工作。
                                        如：递归求斐波那契数就是一个不好的例子。
                                dp解法：
                                    列出优化函数的递推方程及初值(无比关键)。

                            pcode:
                                maxSum_recur 
                                    stop at first == end
                                    sumLeft = maxSum_recur
                                    sumRight = maxSum_recur
                                    the case of non recur.
                                    return the max of those three cases

                            io: 
                                int data[20] = {0, -20, 11, -4, 13, -5, -2};


                            realc++:
                            ---
                                暴力枚举？&toimp
                                    https://blog.csdn.net/weixin_40170902/article/details/80585218
                                    pcode:
                                        loop all start point for sub sequence 
                                            loop all end point for sub seq
                                                compute sum of it, compare and update the max value 
                                dp解法：&toimp
                                    idea: 
                                        https://blog.csdn.net/weixin_40170902/article/details/80585218
                                        动态规划算法设计要点：
                                            (1) (划分)多阶段决策过程，每步处理一个子问题，界定子问题的边界(初值问题)。
                                            (2) 列出优化函数的递推方程及初值(无比关键)。
                                            (3) 问题要满足优化原则或者最优子结构性质。即：一个最优决
                                                策序列的任何子序列本身一定是相对于子序列的初始和结束状态的最优决策序列
                                        子问题后边界
                                        &q The recursive formula for this prob. 
                                        O(N)
                                    pcode:
                                        iterate until Sub-problem back boundary
                                            update with recursive formula
                                    io: 
                                        the same 

                                        const int a[] = { 4, -3, 5, -2, -1, 2, 6, -2 };
                                    realc++: 
                *贪心
                    idea： 
                        很少情况下得到最优解。
                        https://zhuanlan.zhihu.com/p/53334049
                        总是优先选择局部最优解
                    pcode:
                        while best local solution1 possible, do it 
                        while best local solution2 possible, do it 
                        while best local solution3 possible, do it  
                        ...
                    经典问题
                        找硬币（收银） &toimp
                            idea: 
                            pcode:
                            io: 
                            realc++: 
                        背包问题 &toimp
                            idea: 
                            pcode:
                            io: 
                            realc++: 
                        poj 1017 packets &toimp
                            https://tecknight.xyz/blog/poj-1017-packets/
                            idea: 
                                贪心策略，从最大的块开始
                                如果是高度可变？？ 
                                （或许一般也没有这个问题吧）
                                we know all the number at the beginning 
                            pcode:
                                fill with the largest boxes and compute result number 
                                compute the remained space and fill with smaller ones 
                            io: 
                                Sample Input

                                    0 0 4 0 0 1 
                                    7 5 1 0 0 0 
                                    0 0 0 0 0 0 
                                Sample Output

                                    2 
                                    1 
                            realc++: 
                *回溯
                    原子问题经典问题典型案例
                        八皇后问题
                            idea: 
                                该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，
                                    使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法
                                高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果
                                算上include，刚好十行，充分运用了C++标准库
                                https://www.zhihu.com/question/28543312
                                https://www.cnblogs.com/yanlingyin/archive/2011/12/19/2292041.html
                                头两行有冲突，那么后面的不管怎么放，都没有意义了，总会有冲突。
                                解空间剪枝
                                如果考虑全部情况的话，应该每个节点都有四个孩子，然后再来判断最终情况是否满足情况，这会坐更多次数的判断，导致低效率
                                在深度优先遍历解空间的时候每一步都判断当前状态是否满足条件
                                时间复杂度？？
                                    https://www.zhihu.com/question/35812641
                                    一般用回溯法都是一些NP问题，像八皇后啦，背包啦。回溯法的最坏复杂度就是无解的时候。
                                    例如01背包，当然在容量以及物品的体积在一个比较小的范围可以动态规划。然而在一般情形，只能搜索2^n种情况
                                    对于纯粹的穷举类状态空间，它就是指数阶的。如果拿来做动态规划等已经处理过的状态空间遍历，那就是多项式级的。
                                        拿来套树的很多计算时，每个节点访问一次就够所以是O(n)的……
                                    As NQueen function is recursively calling, but is there is any tighter bound possible for this program?
                                    https://sites.google.com/site/nqueensolver/home/algorithm-results
                                    pp tighter bound？？
                                里面的X[k]=X[k]+1,使得第一次判断的是第一列

                            pcode: &toimp
                                ---non-recur 
                                    loop all lines 
                                        check valid with while loop, find first valid place 
                                        if valid 
                                            check finish 
                                            step into next line 
                                        if no valid place found, trace back 
                                ---recur version 

                            io: 
                                no io
                            realc++: 
                                ---mycode:
                                ---https://www.cnblogs.com/yanlingyin/archive/2011/12/19/2292041.html
                                ---https://zhuanlan.zhihu.com/p/52322020
                                    int[] chessBoard;//存第i行皇后的位置j
                                    int count=0;//计数
                                    void init(int n) {//初始化棋盘
                                        chessBoard=new int[n];
                                    }
                                    //按行放皇后,i表示行，n为最多皇后数+1
                                    void putQueue(int i,int n) {//递归函数
                                        if(i==n) {//当放到n时，说明成功
                                            count++;
                                            return;
                                        }//i不等于n，则尝试这一行所有摆放情况
                                        for(int j=0;j<n;j++) {
                                            chessBoard[i]=j;//表示i行j列放皇后
                                            if(checkVaild(i)) {//如果合法，在下一行继续放
                                                putQueue(i+1,n);
                                            }//非法或穷举结束，回溯
                                        }
                                    }
                                    boolean checkVaild(int i) {//冲突检测
                                        for(int j=0;j<i;j++) {//因为按行放的皇后，所以不用检测同行
                                            if(chessBoard[i]==chessBoard[j]||//i,j同列
                                                    chessBoard[i]-chessBoard[j]==i-j||//左上对角线
                                                    chessBoard[j]-chessBoard[i]==i-j)//右上对角线
                                                return false;
                                        }
                                        return true;
                                    }  
                        Bicolorable graph problem &toimp
                            idea: 
                                check if a graph is bicolorable in such a way that no two 
                                    adjacent nodes have the same color.
                            pcode:
                                loop all vertices 
                                    check valid for both cases 
                                    if valid 
                                        check end 
                                        step next 
                                    else 
                                        back trace (just return false)
                            io: 
                                later 
                            realc++:  
                                #include <iostream>
                                using namespace std;
                                int G[50][50]; //adjacency matrix for the graph
                                int num_edges; //number of edges
                                int num_nodes; //number of nodes

                                bool diff_color(int node, int color, int colored[])
                                {
                                    for (int v = 0; v < node; v++)
                                        if (G[v][node] && colored[v] == color)        //check if they have same color and
                                            return false;                                 //if the edge exists between the two nodes.

                                    return true;
                                }

                                bool backtracking(int colored[], int node)
                                {
                                    for (int color = 0; color < 2; color++)          //try for both colors
                                        if (diff_color(node, color, colored))
                                        {
                                            colored[node] = color;                    //set the color to the current vertice
                                            if (node == num_nodes - 1)               //check if the current node == last node
                                                return true;
                                            else
                                                return backtracking(colored, node + 1);    //backtrack it again
                                        }
                                    return false;
                                }

                                int main()
                                {
                                    int u, v, counter;                              //input vertices that are connected
                                    int colored[50];                                //colored vertices,
                                    cin >> num_nodes >> num_edges;

                                    for (int i = 0; i < 50; i++)                    //make all the vertices unconected by
                                        for (int j = 0; j < 50; j++)                 //setting the matrix G[all][all]=0
                                            G[i][j] = 0;

                                    while (num_edges > 0)                          //loop until all edges are entered
                                    {
                                        num_edges--;                                 //num_edges one less
                                        cin >> u >> v;
                                        G[u][v] = 1;                                 //when an edge exists then put in the
                                        G[v][u] = 1;                                 //adjecency matrix a 1
                                    }
                                    if (backtracking(colored, 0))                //check if the graph is bicolorable
                                        cout << "The graph can be bicolored." << endl;
                                    else
                                        cout << "The graph can not be bicolored." << endl;
                                } 
                    + 
                        Backtracking method
                        find a solution by trying one of several choices
                        If the choice proves incorrect, computation backtracks or 
                            restarts at the point of choice and tries another choice.                           
                *二分 
                    原子问题：
                        搜索 
                            基本的 &toimp
                                https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/er-fen-cha-zhao-xiang-jie
                                idea: 
                                    如果是用链表存储的，就无法在其上应用二分查找法
                                    二分查找法主要是解决在“一堆数中找出指定的数”这类问题。
                                    必须是有序的
                                    至于是顺序递增排列还是递减排列，数组中是否存在相同的元素都不要紧
                                    * 查找的key每次和中间数比较
                                pcode:
                                    ---
                                        binarysearch_recur:
                                            check range
                                            if find the desired item, return 
                                            if mid larger than desired val.
                                                binarysearch_recur left range 
                                            otherwise
                                                binarysearch_recur right range 
                                    ---non recur.:
                                        start from initial range 
                                        while check range 
                                            if found, return 
                                            if mid larger than desired val
                                                lower higher bound 
                                            otherwise
                                                enlarge lower bound 
                                io: 
                                    10 
                                    0 1 2 3 4 5 6 7 8 9
                                    5 

                                    5 
                                realc++: 
                                    // C++ program to implement recursive Binary Search 
                                    #include <iostream> 
                                    using namespace std;

                                    // A recursive binary search function. It returns 
                                    // location of x in given array arr[l..r] is present, 
                                    // otherwise -1 
                                    int binarySearch(int arr[], int l, int r, int x)
                                    {
                                        if (r >= l) {
                                            int mid = l + (r - l) / 2;

                                            // If the element is present at the middle 
                                            // itself 
                                            if (arr[mid] == x)
                                                return mid;

                                            // If element is smaller than mid, then 
                                            // it can only be present in left subarray 
                                            if (arr[mid] > x)
                                                return binarySearch(arr, l, mid - 1, x);

                                            // Else the element can only be present 
                                            // in right subarray 
                                            return binarySearch(arr, mid + 1, r, x);
                                        }

                                        // We reach here when element is not 
                                        // present in array 
                                        return -1;
                                    }

                                    int main(void)
                                    {
                                        int arr[100];
                                        for (int i = 0; i < 100; i++)
                                            arr[i] = i;
                                        int x = 10;
                                        int n = sizeof(arr) / sizeof(arr[0]);
                                        int result = binarySearch(arr, 0, n - 1, x);
                                        (result == -1) ? cout << "Element is not present in array"
                                            : cout << "Element is present at index " << result;
                                        return 0;
                                    }
                            左侧边界 &toimp
                            右侧边界 &toimp 
                **递归
                    idea：
                        子问题的解解决父问题
                        思维过程：**
                            1.找子问题：多走两步，最好可以证明是子问题（明确画出来）
                            2.设计参数：变量化参数化(找出原来的为啥不行...)
                                参数要有一定的表达能力
                                参数要同时表达问题和子问题--观察问题和子问题啥不同
                                    规模不同
                                    借助的柱子不同
                                    ...不同
                                写出形式化表达：：
                                    父问题：hanoi(n, f, b, t)
                                    子问题：
                                        hanoi(n-1, f, t, b);
                                        hanoi(1, f, b, t);
                                        hanoi(n-1, b, f, t);
                            3.设计停止条件
                        +这里，都写一下：
                    原子问题：
                        https://segmentfault.com/a/1190000011734845
                        Factorial阶乘 &toimp
                        汉诺塔问题 &toimp
                            描述：
                                A->C借助B
                                A上尺寸由下到上依次变小
                                每次只能移动一个圆盘；
                                大盘不能叠在小盘上面。
                            初始结构只是在A上的情况和任意初始结构（arbitrary initial configuration）
                                的解法不同
                            子问题的解解决父问题
                            ---
                            pcode:
                                hanoi(n, f, b, t)
                                    check...
                                    print...
                                    hanoi(n-1, f, t, b);
                                    hanoi(1, f, b, t);
                                    hanoi(n-1, b, f, t);
                                ---
                                hanoi(a,b,c){//abc 表示个数（不充分）
                                    if(a==1){
                                        
                                    }else{
                                        print a->b;
                                        hanoi(a-1,b,c);
                                        print b->c;
                                    }
                                }
                                ##以上废弃 ：子问题不明确，变量设计不合理 

                                t是二维数组
                                H(imax,t[0],t[1],t[2])	
                                    H(imax - 1, t[0],t[2],t[1])
                                    print t[],t[]
                                    H(imax - 1, t[1],t[0],t[2])
                                ##自己设计，理论上可以

                                H(n,'a','b','c')
                                ##经过理论分析，最简单设计：：父子之间，n变化，借助的柱子也变化（不仅仅是规模变化）
                        回文字符串 &toimp
                            idea: 
                                从前面读和从后面读是否一致？？
                            pcode:
                                isPalindrome_recur
                                    ...
                                    if s[0] = s[n-1], cut them off
                                        return isPalindrome_recur
                                    ...
                            io: 
                            realc++: 

                最优化算法
                    梯度下降
                    遗传算法
                    最小二乘能量最小化
                    IK算法 
                    鱼群算法
                    粒子群算法
                机器学习
                    ...     
                计算几何学算法
                    空间剖分（space partitioning）
                        三角剖分算法
                        Delaunay三角剖分
                    图的对偶变换
                    凸包与半空间求交
                    叉乘、判线段相交、然后写个凸包. 
                    线段交点、多角形面积公式.
                数值模拟算法
                    ray tracing 
                    差分约束系统的建立和求解.
                    数值计算求解偏微分，流体
            
                *记忆化搜索
                    idea 
                        https://www.zhihu.com/question/60730045
                        把已经计算过的记录下来避免重复计算
                        记忆化搜索通常是用在递推关系不那么明确的情况下，使用记忆化可以避免考虑复杂的DP顺序
                        动态规划是一种算法，有两种实现方式：递推和记忆化搜索
                        动态规划空间复杂度比记忆化搜索的空间复杂度要低
                        建议你写记忆化搜索，除非你对你推出来的状态转移方程很有信心，可以写动态规划。

                    典型题目
                        “滑雪”（POJ 1088）
                            idea: 
                            io:
                            pcode: 
                            realc++:
                        树形dp会使用记忆化搜索来实现 https://www.zhihu.com/question/60730045
                            idea: 
                            io:
                            pcode: 
                            realc++:
                        NOIP 2005 采药 https://oi-wiki.org/dp/memo/
                            idea: 
                            io:
                            pcode: 
                            realc++:
            --- tree (not so many)
                隐式表达
                    数组2d/3d oct tree ...
                *tree重建算法
                    idea:
                        Time Complexity: O(n), where n is the total number of nodes in the tree.
                        其实插入和检索可以类似，只是在检索数据的时候赋值而已
                    pcode: define a node？？
                        value
                        Node* left, * right;
                    pcode:
                        insertLevelOrder_recur
                            new node at i 
                            node.left = insertLevelOrder_recur(2 * i + 1)
                            node.right = insertLevelOrder_recur(2 * i + 2)
                    io: 
                        string str = "abcdefghijklmnopqrstuvwxyz";
                    realc++ 层次遍历作为输入
                        ---v1
                            void Cons(Node curNode){
                                curNode.val=Q.pop().val
                                Cons(curNode.left);
                                Cons(curNode.right);
                            }
                            //false! 当然也可以给前序来创建树，那样的话用递归就可以
                        ---v2
                            Node* insertLevelOrder(arr[], Node* root, int i, int n) 
                            { 
                                // Base case for recursion 
                                if (i < n) 
                                { 
                                    Node* temp = newNode(arr[i]); 
                                    root = temp; 
                            
                                    // insert left child 
                                    root->left = insertLevelOrder(arr, 
                                            root->left, 2 * i + 1, n); 
                            
                                    // insert right child 
                                    root->right = insertLevelOrder(arr, 
                                            root->right, 2 * i + 2, n); 
                                } 
                                return root; 
                            } 
                            //too complex!
                        ---v3
                            Node * insertLevelOrder(){
                                root=newNode(a[0]);
                                Queue q;
                                q.push(root);
                                i=0;
                                while(q.size()!=0){
                                    curNode=q.pop();
                                    if(i<n){
                                        curNode->data()=a[i];
                                    }
                                    if(2*i + 1 < n){
                                        //has left child 
                                        l=newNode();
                                        curNode->left=l;
                                        q.push(l);
                                    }
                                    if(2*i + 2 < n){
                                        r=newNode();
                                        curNode->right=r;
                                        q.push(r);
                                    }
                                    i++;
                                }
                            }
                            //Good!
                        ---recur 
                            void insertLevelOrder(string str, Node*& root, int i, int n)
                            {
                                if (i < n)
                                {
                                    root = newNode(str[i]);
                                    insertLevelOrder(str, root->left, 2 * i + 1, n);
                                    insertLevelOrder(str, root->right, 2 * i + 2, n);
                                }
                            }
                    realc++ 先序遍历作为输入
                        是没法直接根据preorder恢复的！ 
                        no-任何一种遍历都是可以恢复的！但是遍历的顺序和idx一定要对应！！！
                            只要是唯一的遍历就ok
                        --- err!
                            Node* PreOrderInsert(a,i){
                                if(i<n){
                                    curNode=newNode();
                                    curNode->data=a[i];
                                    curNode->left=PreOrderInsert(a,i+1);
                                    curNode->right=PreOrderInsert(a,i+2);
                                }else{
                                    return NULL;
                                }
                            }
                        --- err!
                            //i should be global ; should use NULL to，ok 
                            int i=0;
                            Node *PreOrderInsert(int a[], int n)
                            {
                                if (i < n && a[i]!=NULL)
                                {
                                    Node *curNode = (Node *)malloc(sizeof(Node));
                                    curNode->data = a[i];
                                    i++;
                                    curNode->left = PreOrderInsert(a, n);
                                    curNode->right = PreOrderInsert(a, n);
                                    return curNode;
                                }
                                else
                                {
                                    i++;
                                    return NULL;
                                }
                            }       
                    realc++ 完整代码
                        #include<iostream>
                        #include<cstdio>
                        #include<cstring>
                        #include <string>
                        #include <queue>
                        #include <stack>
                        using namespace std;

                        /* A binary tree node has data,
                        pointer to left child and a
                        pointer to right child */
                        struct Node
                        {
                            char data;
                            Node* left, * right;
                        };

                        /* Helper function that allocates a
                        new node */
                        Node* newNode(char data)
                        {
                            Node* node = (Node*)malloc(sizeof(Node));
                            node->data = data;
                            node->left = node->right = NULL;
                            return (node);
                        }

                        void insertLevelOrder(string str, Node*& root, int i, int n)
                        {
                            if (i < n)
                            {
                                root = newNode(str[i]);
                                insertLevelOrder(str, root->left, 2 * i + 1, n);
                                insertLevelOrder(str, root->right, 2 * i + 2, n);
                            }
                        }

                        int idx = 0;
                        void insertPreOrder(string str, Node*& curnode, int n)
                        {
                            if (idx < n)
                            {
                                curnode = newNode(str[idx++]);
                                insertPreOrder(str, curnode->left, n);
                                insertPreOrder(str, curnode->right, n);
                            }
                        }

                        void inOrder(Node* root)
                        {
                            if (root != NULL)
                            {
                                inOrder(root->left);
                                cout << root->data << " ";
                                inOrder(root->right);
                            }
                        }

                        void preOrder(Node* root)
                        {
                            if (root != NULL)
                            {
                                cout << (char)root->data << " ";
                                preOrder(root->left);
                                preOrder(root->right);
                            }
                        }

                        void bfs(Node* root) {
                            std::queue<Node*> q;
                            q.push(root);
                            while (!q.empty()) {
                                Node* cur = q.front();
                                q.pop();
                                if (cur != NULL) {
                                    cout << cur->data << " ";
                                    q.push(cur->left);
                                    q.push(cur->right);
                                }
                            }
                        }

                        void dfs(Node* root) {
                            std::stack<Node*> s;
                            s.push(root);
                            while (!s.empty()) {
                                Node* cur = s.top();
                                s.pop();
                                if (cur != NULL) {
                                    s.push(cur->right);
                                    s.push(cur->left);
                                    cout << cur->data << " ";
                                }
                            }
                        }

                        int main()
                        {
                            string str = 
                                //"abcdefghijklmnopqrstuvwxyz";
                                "abdecfg";
                            //int arr[] = { 1, 2, 3, 4, 5, 6, 6, 6, 6 };
                            //int n = sizeof(str) / sizeof(char) - 1;
                            int n = 7;
                            //int n = sizeof(arr) / sizeof(arr[0]);
                            Node* root = NULL;
                            //insertLevelOrder(str, root, 0, n);
                            insertPreOrder(str, root, n);

                            std::cout << "in-order:" << std::endl;
                            inOrder(root);
                            std::cout << "\npre-order:" << std::endl;
                            preOrder(root);
                            std::cout << "\nbfs:" << std::endl;
                            bfs(root);
                            std::cout << "\ndfs:" << std::endl;
                            dfs(root);
                        }               
                    ---
                        根据preorder和inorder重建 &toimp
                            idea 
                                https://zhuanlan.zhihu.com/p/125678059
                            pcode:
                                build_tree_recur
                                    choose root and find it in inorder seq 
                                    mark pre/inorder left/right sub seq 
                                        build_tree_recur 
                            io: 
                                abedcfg 
                                dbesfcg 

                                levelorder should be abcdefg 
                            realc++: 
                **tree遍历算法
                    //
                        btree一共有四种遍历
                            preorder 
                            inorder 
                            postorder
                            levelorder 
                        其中preorder就是dfs，levelorder就是bfs
                        levelorder具有唯一性，可以根据bfs，levelorder的顺序建立树
                            但是其他三种不行
                        三种之中知道两种就可以恢复出来！！
                        To convert an inherently recursive procedures to iterative, 
                            we need an explicit stack
                        * stack based iterative process 
                        Using Stack is the obvious way to traverse 
                            tree without recursion.
                    preorder_recur 
                        pcode:
                            preorder_recur
                                visit node
                                preorder_recur(node.left)
                                preorder_recur(node.right)
                        realc++:
                            void preOrder(Node* root)
                            {
                                if (root != NULL)
                                {
                                    cout << (char)root->data << " ";
                                    preOrder(root->left);
                                    preOrder(root->right);
                                }
                            }  
                    inorder_recur 
                        ---
                            inorder_recur
                                inorder_recur(node.left)
                                visit node 
                                inorder_recur(node.right)
                    postorder_recur 
                        ---
                            postorder_recur
                                postorder_recur(node.left)
                                postorder_recur(node.right)
                                visit node 
                    preorder non-recur &toimp
                        --- 
                            push root at the top of a stack
                            while stack is not empty.
                                Pop an item from stack and print it.
                                Push right child
                                Push left child
                        //stack<node *> nodeStack;
                    inorder non-recur &toimp
                        ---https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/
                            1) Create an empty stack S.
                            2) Initialize current node as root
                            3) Push the current node to S and set current = current->left until current is NULL
                            4) If current is NULL and stack is not empty then 
                                a) Pop the top item from stack.
                                b) Print the popped item, set current = popped_item->right 
                                c) Go to step 3.
                            5) If current is NULL and stack is empty then we are done. 
                    postorder non-recur &toimp
                        ---https://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/
                            1.1 Create an empty stack
                            2.1 Do following while root is not NULL
                                a) Push root's right child and then root to stack.
                                b) Set root as root's left child.
                            2.2 Pop an item from stack and set it as root.
                                a) If the popped item has a right child and the right child 
                                is at top of stack, then remove the right child from stack,
                                push the root back and set root as root's right child.
                                b) Else print root's data and set root as NULL.
                            2.3 Repeat steps 2.1 and 2.2 while stack is not empty.
                tree变形算法
                    两颗二叉搜索树，如何使用线性的时间复杂度，将它们合并成一颗二叉搜索树。
                    最近公共祖先
                启发式算法
                    kd-tree 其实就是在隐士表达中的启发式算法计算距离
            --- graph
                *graph建立算法
                    idea: 
                        &q draw a graph to show the stru.!!
                    pcode: define a node??
                        value 
                        connection to other nodes (vector<Node*> adjnodes;)
                    pcode：add edge？？relationship？
                        void addEdge(Node* m, Node* n)
                        {
                            m->adjnodes.push_back(n);
                            n->adjnodes.push_back(m);
                        }

                    io: 
                        Node* n0 = new Node("n0");
                        Node* n1 = new Node("n1");
                        Node* n2 = new Node("n2");
                        Node* n3 = new Node("n3");
                        Node* n4 = new Node("n4");
                        vector<Node*> l;
                        l.push_back(n0);
                        l.push_back(n1);
                        l.push_back(n2);
                        l.push_back(n3);
                        l.push_back(n4);

                        addEdge(n0, n1);
                        addEdge(n0, n4);
                        addEdge(n1, n2);
                        addEdge(n1, n3);
                        addEdge(n1, n4);
                        addEdge(n2, n3);
                        addEdge(n3, n4);

                    realc++: define an Edge class to support edge cost 
                        class Edge;
                        class Node {
                        public:
                            Node(string str) {
                                visited = false;
                                val = str;
                            }
                            string val;
                            bool visited;
                            vector<Edge*> adjedges;
                        };
                        class Edge {
                        public:
                            Edge(Node* f , Node* e, int v) {
                                first = f;
                                sec = e;
                                value = v;
                            }
                            Node* first;
                            Node* sec;
                            int value;
                        };
                    realc++: basic imp
                        // A C++ program to print topological sorting of a graph 
                        // using indegrees. 
                        #include<iostream> 
                        #include <list>
                        #include <vector>
                        #include <queue>
                        using namespace std;

                        class Node {

                        public:
                            Node(string str) {
                                val = str;
                            }
                            string val;
                            vector<Node*> adjnodes;
                        };

                        // A utility function to add an edge in an 
                        // undirected graph. 
                        //void addEdge(vector<int> adj[], int u, int v)
                        //{
                        //	adj[u].push_back(v);
                        //	adj[v].push_back(u);
                        //}

                        void addEdge(Node* m, Node* n)
                        {
                            m->adjnodes.push_back(n);
                            n->adjnodes.push_back(m);
                        }

                        // A utility function to print the adjacency list 
                        // representation of graph 
                        void printGraph(vector<Node*> l)
                        {
                            for (int k = 0; k < l.size(); k++) {
                                cout << l[k]->val;
                                for (int i = 0; i < l[k]->adjnodes.size(); i++) {
                                    cout << "-> " << l[k]->adjnodes[i]->val;
                                }
                                cout << endl;
                            }
                        }
                        /*
                            addEdge(adj, 0, 1);
                            addEdge(adj, 0, 4);
                            addEdge(adj, 1, 2);
                            addEdge(adj, 1, 3);
                            addEdge(adj, 1, 4);
                            addEdge(adj, 2, 3);
                            addEdge(adj, 3, 4);
                        */
                        // Driver code 
                        int main()
                        {
                            Node* n0 = new Node("n0");
                            Node* n1 = new Node("n1");
                            Node* n2 = new Node("n2");
                            Node* n3 = new Node("n3");
                            Node* n4 = new Node("n4");
                            vector<Node*> l;
                            l.push_back(n0);
                            l.push_back(n1);
                            l.push_back(n2);
                            l.push_back(n3);
                            l.push_back(n4);

                            addEdge(n0, n1);
                            addEdge(n0, n4);
                            addEdge(n1, n2);
                            addEdge(n1, n3);
                            addEdge(n1, n4);
                            addEdge(n2, n3);
                            addEdge(n3, n4);
                            printGraph(l);
                            return 0;
                        }
                    realc++: with edge cost support 
                        // A C++ program to print topological sorting of a graph 
                        // using indegrees. 
                        #include<iostream> 
                        #include <list>
                        #include <vector>
                        #include <queue>
                        using namespace std;

                        class Edge;
                        class Node {
                        public:
                            Node(string str) {
                                visited = false;
                                val = str;
                            }
                            string val;
                            bool visited;
                            vector<Edge*> adjedges;
                        };
                        class Edge {
                        public:
                            Edge(Node* f , Node* e, int v) {
                                first = f;
                                sec = e;
                                value = v;
                            }
                            Node* first;
                            Node* sec;
                            int value;
                        };

                        void dfs(Node* s) {
                            if (s->visited)
                                return;
                            s->visited = true;
                            cout << s->val << " ";
                            for (auto e : s->adjedges)
                                dfs(e->sec);
                        }

                        void addEdge(Node* m, Node* n, int v)
                        {
                            m->adjedges.push_back(new Edge(m, n, v));
                        }

                        // A utility function to print the adjacency list 
                        // representation of graph 
                        void printGraph(vector<Node*> l)
                        {
                            for (int k = 0; k < l.size(); k++) {
                                cout << l[k]->val;
                                for (int i = 0; i < l[k]->adjedges.size(); i++) {
                                    cout << "- " << l[k]->adjedges[i]->value << "-> " << l[k]->adjedges[i]->sec->val;
                                }
                                cout << endl;
                            }
                        }
                        /*
                            addEdge(adj, 0, 1);
                            addEdge(adj, 0, 4);
                            addEdge(adj, 1, 2);
                            addEdge(adj, 1, 3);
                            addEdge(adj, 1, 4);
                            addEdge(adj, 2, 3);
                            addEdge(adj, 3, 4);
                        */
                        // Driver code 
                        int main()
                        {
                            Node* n0 = new Node("n0");
                            Node* n1 = new Node("n1");
                            Node* n2 = new Node("n2");
                            Node* n3 = new Node("n3");
                            Node* n4 = new Node("n4");
                            vector<Node*> l;
                            l.push_back(n0);
                            l.push_back(n1);
                            l.push_back(n2);
                            l.push_back(n3);
                            l.push_back(n4);

                            addEdge(n0, n1, 1);
                            addEdge(n0, n4, 1);
                            addEdge(n1, n2, 1);
                            addEdge(n1, n3, 1);
                            addEdge(n1, n4, 1);
                            addEdge(n2, n3, 1);
                            addEdge(n3, n4, 1);
                            printGraph(l);

                            cout << endl;
                            dfs(n1);

                            return 0;
                        }
                *graph遍历算法
                    idea: 
                        no recur bfs algorithm present!
                        DFS can be adapted to find all solutions to a 
                            maze by only including nodes on the current path in the visited set.
                    pcode:
                        bfs 
                            wrong!---no recur possible
                                bfs_recur 
                                    setup stop condition
                                    visit 
                                    loop over children 
                                        bfs_recur
                            ---non-recur &toimp
                                bfs 
                                    push to queue 
                                    while queue not empty 
                                        mark as visited 
                                        visit top 
                                        pop 
                                        loop all children 
                                            if not visited 
                                                push to queue 
                        dfs 
                            ---recur
                                dfs_recur 
                                    setup stop condition
                                    loop over children 
                                        dfs_recur
                                    visit 
                            ---non-recur &toimp
                                dfs 
                                    push to stack 
                                    while stack not empty 
                                        mark as visited 
                                        visit top 
                                        pop 
                                        loop all children 
                                            if not visited 
                                                push to stack 
                    io:
                    realc++:
                        void dfs(Node* s) {
                            if (s->visited)
                                return;
                            s->visited = true;
                            cout << s->val << " ";
                            for (auto e : s->adjedges)
                                dfs(e->sec);
                        }
                启发式算法
                    * 属于人工智能，算法题中用的也就是在棋盘问题中用用
                    启发式算法，元启发式算法与超启发式算法的区别
                    启发式算法是依赖于问题的技术
                    试图充分利用这一问题的特殊性。
                    元启发式是独立于问题的技术
                    metaheuristics
                    没有利用问题的任何特殊性，因此可用作黑匣子
                    这使他们能够更彻底地探索解的空间，从而得到一个有希望的更好的解(有时会与全局最优相吻合)
                    仍有必要对其内在参数进行一些微调，以便使该技术适应手头的问题。
                    必要对其内在参数进行一些微调，以便使该技术适应手头的问题。
                    超启发式算法（Hyper-heuristics）
                    只是启发式算法针对特殊问题找出较优解，而元启发式对普遍问题，不加入任何特殊条件找出通解空间
                    超启发算法的特殊性在于它找出的空间不是解的空间，而是启发式或元启发式的空间。
                    启发式搜索启发式
                    搜索得出的空间也不同，启发式算法（heuristics）搜索得出的是特殊解空间，元启发式算法（metaheuristics）搜索得出的是普遍问题的解空间，而超启发式算法（Hyper-heuristics）搜索得出的是启发式的空间。
                    一个是problem independent，一个是problem specific，可以意会一下
                    元启发式算法包括禁忌搜索算法、模拟退火算法、遗传算法、蚁群优化算法、粒子群优化算法、人工鱼群算法、人工蜂群算法、人工神经网络算法等。
                    50年代：逐步繁荣，其中 贪婪算法和局部搜索 等到人们的关注
                    由于NP理论，启发式算法就解得全局最优性无法保证。
                    模拟退火算法（Simulated Annealing Algorithm），人工神经网络（Artificial Neural Network），禁忌搜索（Tabu Search）相继出现
                    为什么要引出启发式算法，因为NP问题，一般的经典算法是无法求解，或求解时间过长，我们无法接受
                    启发式算法得到的解只是近似最优解（近似到什么程度，只有根据具体问题才能给出）
                    如果NP=P启发式算法就不在有存在的意义
                    禁忌搜索：模拟人的经验，通过禁忌表记忆最近搜索过程中的历史信息，禁忌某些解，以避免走回头路
                    蚂蚁算法：模拟蚂蚁的行为，拟人拟物，向蚂蚁的协作方式学习。
                    从随机的可行初始解出发，才用迭代改进的策略，去逼近问题的最优解
                    他们的基本要素：（1）随机初始可行解；（２）给定一个评价函数（常常与目标函数值有关）；（３）邻域，产生新的可行解；（４）选择和接受解得准则；（５）终止准则。
                *最小生成树算法
                    idea:
                        最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。
                        Kruskal算法, 也叫“加边法”
                            按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗
                            不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。
                        Prim， 此算法可以称为“加点法
                        最小生成树是一副连通加权无向图中一棵权值最小的生成树。
                        它在实际中有什么应用呢？比如说有N个城市需要建立互联的通信网路，如何
                            使得需要铺设的通信电缆的总长度最小呢？这就需要用到最小生成树的思想了。
                        如果是连通图，则至少存在一棵最小生成树，有时最小生成树并不唯一
                        怎么才能判断最小生成树是否唯一呢？
                            在构造MST的时候，有可能可以选择不同的边，这样构造出来的最小生成树不相同，但最小生成树的权是唯一的。
                            https://blog.csdn.net/Akatsuki__Itachi/article/details/79072432
                        qq compare dijkstra and prim 
                            Dijkstra算法用于构建单源点的最短路径树(MST)——即树中某个点到任何其他点的距离都是最短的。
                            可以用于有向图，但是不能存在负权值(Bellman-Ford可以处理负权值)。
                            例如，构建电路板，使所有边的和花费最少。只能用于无向图。
                            MST中任意AB两点之间的距离，并不比原始图中AB的距离短，
                                即原始图中可能存在边E(A,B)**小于**MST中的E(A,B)
                            两个伪算法的差别只在于最后循环体内的松弛操作。
                            Dijkstra的松弛操作加上了到起点的距离，而Prim只有相邻节点的权值
                            都是使用贪婪和线性规划，每一步都是选择权值/花费最小的边
                            主问题包含n个子问题，而且其中有重叠的子问题
                            当边的权值都为1的时候，可以用bFS（广度优先搜索）优化时间复杂度。
                            * 仅仅区别于松弛操作
                        并查集
                            是使用树结构实现的
                            对N个元素并查集进行的一次操作的复杂度是O(α(N))，
                                α(N)是阿克曼函数的反函数。这个复杂度是比O(LogN)还要快的。
                            
                        https://zhuanlan.zhihu.com/p/34922624
                        complexity 
                        * compare kruskal and prim:
                            //思维的角度不同出发点不同带来的复杂度效果完全不同，目前只要会用就ok，
                                发明的时候需要不断回溯！
                                回溯的本质就是看看上一步有没有出错
                            https://www.zhihu.com/question/26806466
                            Kruskal：O(E)
                            prim: O(n^2)
                                prim用fib堆的话...
                                prim改一改还可以[公式]求次小生成树
                            Prim算法从顶点的角度出发，每次选择距离当前节点最近的节点加入，直到所有节点都加入。
                            Kruskal算法从边的角度出发，每次总是选择权重最小的边加入，直到加入n-1条边为止。
                                （如果加入一条边后出现回路，skip这条边）。
                            Prim算法需要维持一个堆数据结构（实际实现中用priority_queue比较多）
                            Kruskal算法需要union-find的数据结构
                            * Prim算法，该算法的时间复杂度为O(n²)，与图中边数无关，该算法适合于稠密图，
                                而另外一种是Kruskal，该算法的时间主要取决于边数，它较适合于稀疏图。
                            prim适合点多的稠密图，kruskal适合边多的
                            ** Kruskal‘s algorithm 的背后是矩阵胚理论
                        局部贪心和全局更新思想！ 

                    pcode:
                        ---Kruskal &toimp
                            * rank all edges and loop over all edges 
                                if the vertex connected are belones to two diff. trees <- must use union find DS?
                                    add this edge and mark them as the same tree 
                            if only one tree found, MST found, else no MST present 
                            
                        ---prim &toimp
                            initialize dist property for each edge to inf 
                            choose the source node s and update dist for all vertices 
                            * loop all points in Q (not visited)
                                find vertex with minimal dist in Q 
                                add this v to S set (mark as visited)
                                update all dist for all vertices in Q = w(u,v)
                    io:
                        https://img-blog.csdn.net/20160714130435508
                        https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/03.jpg?raw=true
                    realc++:
                        ---https://zhuanlan.zhihu.com/p/34922624
                        ---
                    ---
                        最小度限制生成树（变种）
                *最短路径算法 
                    dijkstra 
                        idea: 
                            局部贪心全局更新（松弛操作）
                            在最短路算法，如Dijkstra和Bellman-Ford，会对边进行“松弛”操作
                            如何直观地理解“tense”和“relaxation”的概念？
                            我们可以很自然的看到s点和u点之间较短的那条边处于紧绷状态，
                                而较长的那条边处于松弛状态。因此非常形象的把这个操作称为松弛操作
                            数学意义上所说的松弛（比如Relaxation (iterative method)，比如Slack variable - Wikipedia）
                                是指减少对变量的约束
                                原来的约束对于dist(v)来说就不再是能将dist(v)收的最紧的约束了，相当于这个原约束被“松弛”了。
                            * 减少变量约束（这里理解为更新权重）
                            “松弛” 就是变量更新（全局上感觉是在松弛）
                            https://upload.wikimedia.org/wikipedia/commons/thumb/e/e4/DijkstraDemo.gif/440px-DijkstraDemo.gif
                                A demo of Dijkstra's algorithm based on Euclidean distance. Red lines are the shortest path covering,
                                Blue lines indicate where relaxing happens
                            https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Pseudocode
                            +Specialized variants
                            is a paraphrasing of Bellman's famous Principle of Optimality in the context of the shortest path problem.
                            单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，  
                            直到扩展到终点为止
                            算法要求图中不存在负权边。
                            第一组为已求出最短路径的顶点集合
                            第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中
                            总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度
                            类似广度优先搜索的方法解决赋权图[8]的单源最短路径问题
                            产生一个最短路径树
                            贪心是一种特殊的动态规划，动态规划的本质是独立的子问题，而贪心则是每次可以找到最优的独立子问题
                            贪心和动归不是互斥的，而是包含的，贪心更快，但约束更强，适应范围更小。
                            bfs，dp，贪心三个方法都是解决最优化问题的方法
                            最优子问题
                            *pseudo:
                                初始化
                                    贪心选择（优先队列）/最优子问题？/ +少的换乘次数
                                    更新
                            Dijkstra算法给出了一个对于特定的Bellman Equation的一种求解方法，所以从这个意义上我觉
                                得可以认为它是一种“广义”动态规划算法。
                            阿里数学竞赛初赛那道送外卖的题，其实很容易写出Bellman Equation，
                                然后尝试去求解这个方程会发现最后给出的解可以由类似Dijkstra的算法算出
                            在边权全是 1 的图上，我们可以用 BFS 求单源最短路。Dijkstra 是 BFS 的推广。
                            需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序
                            每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。
                            变体
                                在原来Dijkstra算法的基础上增加若干个的条件，比如最短路径上的点权之和、
                                    边权之和或者求解出存在多条最短下最短路径的条数
                                https://blog.csdn.net/qq_39445165/article/details/93311601
                        pcode: &toimp
                            initialize dist property for each edge to inf 
                            choose the source node s and update dist for all vertices 
                            * loop all points in Q (not visited)
                                find vertex with minimal dist in Q 
                                add this v to S set (mark as visited)
                                update all dist for all vertices in Q = w(u,v) + u.dist 
                        io: 

                        realc++:
                    最佳优先（Best First）算法 
                        idea：  
                            优先扩展到终点距离最近的那个点 
                        pcode: &toimp
                            similar 
                        io: 
                            similar 
                        realc++:
                    a*
                        idea:
                            https://zhuanlan.zhihu.com/p/54510444
                            A*算法最初发表于1968年，由Stanford研究院的Peter Hart, Nils Nilsson以及Bertram Raphael发表。
                            * 它可以被认为是Dijkstra算法的扩展。
                            bfs这种算法就像洪水（Flood fill）一样向外扩张
                            由于借助启发函数的引导，A*算法通常拥有更好的性能。
                            Dijkstra算法是由计算机科学家Edsger W. Dijkstra在1956年提出的。
                            当图形为网格图，并且每个节点之间的移动代价是相等的，那么Dijkstra算法将和广度优先算法变得一样。
                            但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）
                                的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best First）算法
                                也就是dist中存的是到终点的距离？
                            但是如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径
                                也就是权重不同的时候
                            A*算法实际上是综合上面这些算法的特点于一身的。
                            A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为open_set和close_set
                            从open_set中选取优先级最高的节点n
                            &toimp 
                                algovis pj 
                                ref. https://zhuanlan.zhihu.com/p/54510444
                            是一种基于启发式搜索的算法，
                            该算法综合了BFS(广度优先搜索)和Dijkstra算法的优点：在进行启发式搜索提高
                            算法效率的同时，可以保证找到一条最优路径（基于评估函数）。
                            Dijkstra算法虽然可以保证找到一条最短的路径, 但不如A*算法这样简便快速.
                            Dijkstra的搜索深度在某些情形下也容易变得不适用.
                            估算距离
                            通过对上一篇A*寻路算法的学习，我们对A*寻路应该有一定的了解了，但实际应用中，需要对算法进行一些改进和优化。
                            图形中相邻节点之间的移动代价并不相等。例如，游戏中的一幅图，既有平地也有山脉，那么游戏中的角色在平地和山脉中移动的速度通常是不相等的。
                            不考虑节点移动代价差异的广度优先搜索与考虑移动代价的Dijkstra算法的运算结果：
                                https://zhuanlan.zhihu.com/p/54510444
                            BFS反而更快（可视化）
                            如果一样则两种算法相等
                            *最佳优先算法
                                初始化
                                    取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点
                                    更新所有点距离
                            *A*算法 
                                初始化
                                    通过下面这个函数来计算每个节点的优先级：f = g + h 
                                        距离起点的代价(dijkstra) + 预计代价(最佳优先算法)
                                    更新所有点距离
                            每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。
                            A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，
                                这通常称之为open_set和close_set。
                            q- 当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时发生啥了？
                                算法就退化成了Dijkstra算法。
                            当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。
                            hn应该等于确切的代价，但是实际很难
                                在没有达到终点之前，我们很难确切算出距离终点还有多远。
                            如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。
                            在另外一个极端情况下，如果h()n相较于g(n)大很多，则此时
                                只有h(n)产生效果，这也就变成了最佳优先搜索
                            具体性能取决于使用场景！ 
                            通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径
                            是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。
                            如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）
                            https://zhuanlan.zhihu.com/p/54510444
                            https://github.com/paulQuei/a-star-algorithm
                            如果感兴趣这篇文章中的动图是如何制作的，请看我的另外一篇文章：使用Matplotlib绘制3D图形 - 制作动图。
                                https://paul.pub/matplotlib-3d-plotting/#id-
                            改进
                                https://blog.csdn.net/silangquan/article/details/40516625?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1
                            A* is an informed search algorithm,
                            formulated in terms of weighted graphs
                            smallest cost (least distance travelled, shortest time, etc.).
                            until its termination criterion is satisfied.
                            selects the path that minimizes
                            a heuristic function that estimates the cost of the cheapest path from n to the goal.
                            A* terminates when the path it chooses to extend is a path from start to goal 
                            or if there are no paths eligible to be extended
                            The heuristic function is problem-specific
                            never overestimates the actual cost to get to the goal
                            openSet 
                            This operation can occur in O(1) time if openSet is a min-heap or a priority queue
                            in O(1) time
                        pcode: &toimp
                            initialize dist property for each edge to inf 
                            choose the source node s and update dist for all vertices 
                            * loop all points in Q (not visited)
                                find vertex with minimal fval in Q --> 把dist改成优先级，fval函数（包括但不限于g）
                                add this v to S set (mark as visited)
                                update all dist for all vertices in Q = w(u,v) + u.fval 
                        io: 
                            similar 
                        realc++: 
                图论算法    
                    欧拉路
                    哈密顿路
                    Kosaraju算法
                        idea
                            https://zh.wikipedia.org/wiki/Kosaraju%E7%AE%97%E6%B3%95
                            强连通分量（英语：Strongly connected component）是图论中的概念
                            图论中，强连通图指每一个顶点皆可以经由该图上的边抵达其他的每一个点的有向图
                            强连通分量则是指一张有向图G的极大强连通子图G
                            极大
                            如果将每一个强连通分量缩成一个点，则原图G将会变成一张有向无环图
                            一张图被称为有向无环图当且仅当此图不具有点集合数量大于一的强连通分量
                            因为有向环即是一个强连通分量
                            任何的强连通分量皆具有至少一个有向环。
                            Kosaraju算法、Tarjan算法、Gabow算法皆为寻找有向图强连通分量的有效算法
                            由于在Tarjan算法和Gabow算法的过程中，只需要进行一次的深度优先搜索，因而相对Kosaraju算法较有效率
                            寻找强连通分量的算法，也可以用来解2-SAT（2-satisfiability）问题。Aspvall, Plass & Tarjan（1979）
                    LCA问题
                        给出两棵树S和T，且S的所有元素都比T的元素要小。下面的步骤可以把它们连接成一棵树
                        我们定义一个节点也是其自己的后代，因此如果v是w的后代，那么w就是v和w的最近公共祖先。
                        最近公共祖先（英语：lowest common ancestor）
                        最近公共祖先是两个节点所有公共祖先中离根节点最远的
                        为了计算树中两个节点v和w之间的距离        
                网络流算法
                    图的割边和割点
                    二分图匹配
                        Hopcroft-Karp
                **拓扑排序 
                    A topological sort or topological ordering of a directed graph
                    a linear ordering of its vertices such that for every directed 
                        edge uv from vertex u to vertex v, u comes before v in the ordering. 
                    若存在一条有向边从u指向v，则在拓扑排序中u一定出现在v前面。
                    用来解决有向图中的依赖解析问题。
                    循环依赖存在的话就没有拓扑排序
                    pcode: 
                        选择入度为0的节点输出；
                        从有向图中删除此节点以及出边；
                        循环上述过程，直到有向图中无节点或无入度为0的节点，循环结束；
                        若循环结束后，如果有向图中无节点，那么说明可以拓扑排序；
                            如果有向图中仍存在节点，那么说明存在环，即不可被拓扑排序。
                    典型问题 
                        课程表 https://mp.weixin.qq.com/s/vqJ26hLZyQ9LCGjUAuoAQQ &toimp
                            idea: 
                                先修课程, 2, [[1,0]] , 2，[[1,0]，[0,1]] false 
                                这道题目的核心就是判断有向图是否存在环
                            pcode:
                                loop all nodes to check 
                                    if incoming degree is 0, push to stack 
                                while stack not empty 
                                    count ++ 
                                    loop all nodes connected to this 
                                        decrease the corresponding incoming degreee by 1 
                                        if is 0
                                            push into the stack  
                                check if count equs to the number of courses 
                            io: 
                                2, [[1,0]] true, 2，[[1,0]，[0,1]] false 
                            realc++: 
                                https://mp.weixin.qq.com/s/vqJ26hLZyQ9LCGjUAuoAQQ
                Beam Search（集束搜索）
                    一种启发式图搜索算法，通常用在图的解空间比较大的情况下，
                        为了减少搜索所占用的空间和时间
                Hertel-Mehlhorn算法
                    寻找一个覆盖整个地图的最简凸多边形集合。
            --- spec
                NP problems 
                    TSP Travelling salesman problem
                    Minesweeper 
                    Knapsack problem
                    Sudoku
                    Set TSP problem
                    Hitori一个数字矩阵
                    马踏棋盘
                        其实是哈密顿回路问题，但是有棋盘大小制约，本质是NP hard
                    Graph coloring
                    最小st割问题
                    子集合加总问题
                        给定集合{−7, −3, −2, 5, 8}，答案是YES，因为子集{−3, −2, 5}的数字和是0
                        可以想成是背包问题的一个特例
                    圍棋是一種 PSPACE-hard 的問題
                    +各种棋类
                        概括：
                            启发式搜索和优化减枝的过程
                            国际象棋（他是台湾人，说的是西洋棋）的状态复杂度是 2^64 次方，而围棋则达到 2^128 次方
                            就在今天2016-1-28，《Nature》杂志以封面论文的形式，介绍了 
                                Google DeepMind 开发的人工智能程序 AlphaGo，它击败了欧洲围棋冠军樊麾
                        围棋--唯一一种电脑下不赢人的大众棋类
                            围棋虽说是“千古无同局”，
                            但在局部及开局还是有很多相似或者相同的模式会反复出现，
                            DCNN能够抓住这些模式并且在实战中灵活运用。
                        象棋跳棋
    ---
    practice:
        * 面试经验
            思路也是有分的
            要明确题目的范围，输入输出
            写出的代码或许不会是bug-free的，不要太有压力
                先把思路说出来而后搭建框架，而后完善细节！
            排序算法：快速排序、归并排序、计数排序 搜索算法：回溯、递归、剪枝技巧 图论：最短路、最小生成树、网络流建模 动态规划：背包问题、最长子序列、计数问题 基础技巧：分治、倍增、二分、贪心
            数组与链表：单 / 双向链表、跳舞链 栈与队列 树与图：最近公共祖先、并查集 哈希表 堆：大 / 小根堆、可并堆 字符串：字典树、后缀树
            建议小伙伴将所有题目都练习 2～3 遍，吃透每一道题目哦。
            https://www.zhihu.com/question/24964987
            https://juejin.im/post/58ca051f61ff4b0060165122#heading-43
            Leetcode 分类顺序表
            https://cspiration.com/leetcodeClassification
            建议：400题全部刷完，再精刷这250题。
            https://cspiration.com/leetcodeClassification
            留学两年多，刷题过三千
            CS科班出身，但非ACMer，从没接触过ACM。从树的遍历捡起算法，纯自己刷题。
            如果能把Leetcode 前400题都刷透，再做做面经题，足以面试各大公司。
            或者说，以算法题角度，横扫各大公司。
            但在现实生活中，能把400题刷明白的，十中无一。
            针对 Data Science 这个职位
        * mixed行业信息（关于刷题，刷什么怎么刷）
            * 刷题先刷思路，看思路能不能跟别人对上，各种复杂度都要有
            排序算法：快速排序、归并排序、计数排序 
            搜索算法：回溯、递归、剪枝技巧 
            图论：最短路、最小生成树、网络流建模 
            动态规划：背包问题、最长子序列、计数问题 
            基础技巧：分治、倍增、二分、贪心
            数组与链表：单 / 双向链表、跳舞链 
            栈与队列 树与图：最近公共祖先、并查集 哈希表 堆：大 / 小根堆、可并堆 字符串：字典树、后缀树
            建议小伙伴将所有题目都练习 2～3 遍，吃透每一道题目哦。
            https://www.zhihu.com/question/24964987
            https://juejin.im/post/58ca051f61ff4b0060165122#heading-43
            &
            Leetcode 分类顺序表
            https://cspiration.com/leetcodeClassification
            建议：400题全部刷完，再精刷这250题。
            https://cspiration.com/leetcodeClassification
            留学两年多，刷题过三千
            CS科班出身，但非ACMer，从没接触过ACM。从树的遍历捡起算法，纯自己刷题。
            如果能把Leetcode 前400题都刷透，再做做面经题，足以面试各大公司。
            或者说，以算法题角度，横扫各大公司。
            但在现实生活中，能把400题刷明白的，十中无一。
            针对 Data Science 这个职位

            讲的都是普通的数据结构，咱不是搞算法竞赛的，野路子出生，我只会解决常规的问题。
            「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组
            了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式
            数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表
            对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改
            在不同的应用场景，尽可能高效地增删查改。
            线性迭代结构
            链表遍历框架，兼具迭代和递归结构
            所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构
            根据具体问题在框架上添加代码就行了
            数据结构是工具，算法是通过合适的工具解决特定问题的方法
            ，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。
            先刷二叉树，先刷二叉树，先刷二叉树！
            二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题
            本质上该算法也就是一个前序遍历。
            这不就是个中序遍历嘛，对于一棵 BST 中序遍历意味着什么，应该不需要解释了吧
            刷完整个专题
            再看看回溯算法，前文回溯算法详解干脆直接说了，回溯算法就是个 N 叉树的前后序遍历问题，没有例外
            有时候按照流程写出解法，说实话我自己都不知道为啥是对的，反正它就是对了。。。
            这就是框架的力量，能够保证你在快睡着的时候，依然能写出正确的程序
            就算你啥都不会，都能比别人高一个级别。
            首先这本书是适合初学者的。总是有很多读者问，我只会 C 语言，能不能看《算法4》
            算法其实是一种思维模式，和你用什么语言没啥关系。我们的文章也不会固定用某一种语言，而是什么语言写出来容易理解就用什么语言
            使得任何一条边的两个顶点颜色不同
            算法方面，常见的操作是如何判定一幅图是不是二分图
            不存在演员和演员相连，电影和电影相连的情况
            回顾二分图的定义，如果对演员和电影顶点着色，肯定就是一幅二分图
            比如说社交网络中「间隔度数」的计算（六度空间理论应该听说过）等等
            如果交易的金额大一些的话，赚的钱是很可观的，这种空手套白狼的操作就是套汇
            现实中交易会有种种限制，而且市场瞬息万变，但是套汇的利润还是很高的，关键就在于如何快速找到这种套汇机会呢？
            这个环上的权重之积大于 1，只要在顺着这个环交易一圈就能空手套白狼。
            可以先把所有边的权重 w 替换成 -ln(w)，这样「寻找权重乘积大于 1 的环」就转化成了「寻找权重和小于 0 的环」
            就可以使用 Bellman-Ford 算法在 O(EV) 的时间内寻找负权重环，也就是寻找套汇机会。
            Bellman-Ford 算法
            大部分人学算法不就是巩固计算机知识，对付面试题目吗？
            算法导论》中充斥大量数学证明，而且很多数据结构是很少用到的，顶多当个字典用。

            本人研究方向是NLP，面的是AILab语音部门
            面试官应该是未来同事，上来在白板上先描述了第一道题
            开始虐了）先写道题吧。用Tensorflow写一个KNN算法
            （面试官看我被虐的有点惨，笑着说换道题吧）用C++写个简单的矩阵乘法吧
            两个上三角矩阵相乘如何优化？（完全懵逼，答不出来）
            职业规划
            HR交叉面
            刷题还是很必须的。要做到快速出题，实在不会的题也得写个次优解，千万不要挂机。
            leetcode958 判断是否是完全二叉树。之前刷面经看到了，非常感谢大家分享面经
            一道算法题，大概就是简单的dp
            一道算法提，就是数组中求最大的k个值
            互联网大厂面试算法笔记
            先做树的题目，然后是图论，因为图论可以看作是树的一种扩展，然后是递归、回溯，之后是DFS、BFS，然后是动态规划，最后是字符串和数组。
            直到问的你答不上来为止，以此来探寻你的技术边际
            https://www.jianshu.com/p/fd5e398a3007
            伪代码的"展示"作用大于他的"草稿"作用, 就跟写论文之前要不要先写ppt一样.
            多年以后，人都会只记得伪代码，而背不出源代码。
            for,end for,do,while, end while,if,else都用加粗
            不要使用括号，而是使用缩进表示代码块
            需要有input，output
            5. 需要有行标
        --
        * mixed prob-solution list:
            //（使用）(预计几千个问题至少)(先刷思路！)
            // 
                问题一般都有多种解法，甚至是一些算法的结合
                我们要做的是提高效率，降低时空复杂度
                一旦判断题目是有关动态规划的题，第一步就是要找到他的最优子结构
                暴力解法一定都实现一下
                *要有信心，刷题很简单需要的知识很少！ 
                    ---思路：
                        1.暴力，基本数据操作 
                        2.观察题目特点（是不是正好某种结构？
                            排序试试？递归？动态规划？子结构？）
                    ---开始写：
                        1.基本的各种变量【声明】 
                        2.条件【分支】的熟练运用
                动态规划是用的很多的一种技术，考的很多
                
            * 0.数学计算
                水仙花数 
                质数
            * 1.完美匹配数据结构型的问题（直接使用相应结构）or 完美匹配基本算法问题（直接使用算法，比如bfs）
                jiuduoj 1078（基本的树遍历）
                poj 3750 小孩报数问题（循环链表）
            * 2.套路可以达到较好效果的问题（有可能有套路的复合以及灵活运用！）
                排序问题（...排序思想）
                汉诺塔问题（递归...）
                背包问题（暴力枚举...动态规划）
                套利问题（...Bellman-Ford 算法）
                八皇后问题（回溯）
                计算编辑距离（动态规划）
                数组均分（转化成背包，动态规划）
                    theory: 
                    io: 
                    realc++: 
                poj 1050 最大子矩阵（最大子序列，dp）
                    idea: 
                    io: 
                    realc++: 
                ...
                887.鸡蛋掉落（二分，线搜，穷举加备忘录/DP table 优化）
                    theory: 
                        找到鸡蛋恰好摔不碎的那层楼
                        这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索
                        使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。
                        二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔
                            鸡蛋有关系，实际上没有半毛钱关系。
                            能用二分搜索是因为状态转移方程的函数图像具有单调性，
                            可以快速找到最值
                        动态规划详解（修订版）》和《回溯算法详解（修订版）》已经动笔了，教大家
                        * 用模板的力量来对抗变化无穷的算法题
                    io: 
                    realc++: 
                kSum问题 （排序，双指针）
                ---leetcode: (排序以后从第七页开始，中档题)
                    8	 String to Integer (atoi)  
                        位操作  
                    29	 Divide Two Integers 
                        位操作
                    LCP 03. 机器人大冒险
                        基本功，读入与操作数据
                    1488. 避免洪水泛滥
                        基本数据操作
                    866. 回文素数
                        求值循环与判断
                    1201. 丑数 III
                        数论，最大公约最小公杯
                    468. 验证IP地址
                        基本数据操
                    
                    
                     
        * 互联网公司里的实际算法使用情形
            百万级的数据排序检索 map? list? hashmap? vector?......   
        * c++ stl boost中的结构算法使用情况
            summ.
                vector中的sort用的是哪种？
                map底层是啥实现的？
            https://www.cnblogs.com/virusolf/p/4963229.html
                STL中vector，Map，Set的实现原理
                vector是动态空间，随着元素的增加，它的内部机制会自行扩充空间以容纳新元素
                vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦vector的旧有空间满载，如果客户端每新增一个元素，vector的内部只是扩充一个元素的空间，实为不智
                vector维护的是一个连续线性空间，所以支持vector随机存取
                Map是关联容器，以键值对的形式进行存储
                以红黑树的结构实现，插入删除等操作都可以在O(log n)时间内完成
                map1.insert(pair<int,string>(102,"wobeitianjia")); 　
                元素查找：map1.find(key) 返回一个迭代器指向键值为key的元素
                先查找元素，map<int ,string>::iterator it=map1.find(key); 找到之后map1.erase(it);
                sort函数，因为map中key按照升序进行排列的，所以不能使用sort函数。
                map中的swap函数，交换的是两个容器而不是一个容器中的元素交换。
                Set是关联容器
                set中每个元素都只包含一个关键字，set支持高效的关键字查询操作—检查每一个给定的关键字是否在set中
                set是以红黑树的平衡二叉检索树结构实现的
                支持高效插入删除，插如元素的时候会自动调整二叉树的结构
                构造set集合的主要目的是为了快速检索，不可直接去修改键值
                https://wiki.jikexueyuan.com/project/java-collection/hashset-and-hashmap.html
                HashSet 实现了 Set 接口，它不允许集合中有重复的值，
                如果我们没有重写这两个方法，将会使用这个方法的默认实现。
                HashMap 实现了 Map 接口，Map 接口对键值对进行映射。Map 中不允许重复的键。
                vector支持快速的查找，但是插入费时。
                关于hash_map，它与map的实现机制是不一样的，map内部一般用树来实现，其查找操作是O(logN)的，这个没有争议，我就不多说了
                hash_map的查找，内部是通过一个从key到value的运算函数来实现的，这个函数“只接受key作为参数”
                所以认为它是O(1)级的
                在不碰撞的情况下，hash_map是所有数据结构中查找最快的
                最坏的情况下，它的计算量就退化到O(N)级，变成和链表一样。
                如果说   hash_map   是所有容器中最慢的，也只能说：“最拙劣的hash函数”会使hash_map成为查找最慢的容器
                最凑巧的排列能使冒泡排序成为最快的排序算法。
                如果hash_map选择了病态的散列函数,他也可能比map慢得多
                现在的大多数编译平台支持hash   table，但从可移植性方面考虑，还是不用hash   table的好。
                空间浪费往往也惊人
                没有高效低碰撞的算法，hash_xxx没有意义。 
                而对不同的类型，数据集，不可能有优良的神仙算法。必须因场合而宜。 
                百万级的数据放到vector不大合适
                map每插入一个数据，都要排序一次。所以速度反不及先安插所有元素，再进行排序
                涉及到查找的话用map比较好，因为map的内部数据结构用rb-tree实现
                而用vector你只能用线性查找，效率很低。
            +http://net.pku.edu.cn/~yhf/UsingSTL.htm
            
        * java中数据结构和算法使用情况？？
            summ.
                hashmap底层是啥？ 
                collection类中有很多结构！ 
            +https://wiki.jikexueyuan.com/project/java-collection/hashset-and-hashmap.html
        * 高度概括总结，如何解决现实问题highlev question 
            什么时候需要hash？什么时候需要tree？什么时候最小化堆是正确的答案？
            针对不同的情形决定使用什么样的数据结构算法
    ---
    old ones     
        ---simple questions tasks
            运筹学问题 ！！
                TSP问题
                SAT问题
                    SAT的问题被证明是NP难解的问题。
                        目前解决该问题的方法主要有完备的方法和不完备的方法两大类。
                        完备的方法优点是保证能正确地判断SAT问题的可满足性，
                        但其计算效率很低，平均的计算时间为多项式阶
                    传统的方法有：枚举法、局部搜索法和贪婪算法等，但由于搜索空间大，
                        问题一般难以求解。对于像SAT一类的NP难问题，
                        采用一些现代启发式方法如演化算法往往较为有效。
                NP问题与近似算法
            区间最值算法ST
                ST 算法是 RMQ（Range Minimum/Maximum Query）
                中一个很经典的算法，它天生用来求得一个区间的最值
            // DS free tasks from oj! for all lan. (vs lan-feature based)
            //  heuristics: 
                部分高中数学题目，尤其是数论有关
                poj水题目, or other ojs 
                c语言遗产
                data sci., basic vis. , img based
                search online "basic programming tasks" 
                    https://www.w3resource.com/cpp-exercises/basic/index.php
                    ...
                basic math problems
                small logic problems
                paint in command linea 
                (what you have done as bechlor)
                https://blog.csdn.net/qq429205464/article/details/6732899
                https://blog.csdn.net/qq_17246605/article/details/52136415
            t- math calcu:
                add 10 numbers together - use calcu.or to varify
                求1+2+3+......+n
                sum of 2d array/3d array - calculator
                gaussian blur, stencil function , compare from net
                出现次数最多的数
                zigzag-https://blog.csdn.net/wangfengfan1/article/details/47071095
                    -later 
            t- find.spec.numbers
                prime
                shuixianhua shu
                    pcode:
                        for 
                            if 
            t- 基本排序算法*4 ok 
                -shouldbesummerized
                -net
            t- rabbit:20 iteraters, 4 each line 
                -snippets
            t- fibonaqi:store 40 numbers , F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）
                loop / swap
                -snippets
            t- 百钱买百鸡:公鸡5文钱一只，母鸡3文钱一只，小鸡3只一文钱， 用100文钱买一百只鸡,其中公鸡，
                母鸡，小鸡都必须要有，问公鸡，母鸡，小鸡要买多少只刚好凑足100文钱？
                brust loop
                -snippets
            t- 魔方矩阵calcu-将自然数1到N^2填充N行N列的方阵，使方阵中每行、每列及两条主对角
                线上的N个数的和都等于N*(N^2+1)/2，这样的方阵称为N阶魔方矩阵（幻方）
                +
                    strategy 
                        魔方矩阵的构造分为三种情况：N为奇数、N为4的倍数、N为其他数（偶数，4N+2的形式）
                        https://www.cnblogs.com/xkfz007/archive/2012/11/13/2767407.html
                    brust loop ok 
            t- Magic square judge
                +https://blog.csdn.net/qq_36203090/article/details/55223867
                loop/2d array
            t- sum/multiple/xxx(basic math) two numbers 
                input: 12 24
                output: 36
                check: with calcu. (online is ok)
            t- loop over to print numbers/shapes
                10times 2d loop
                yanhui triangle 
                triangle with * 
                ...
            t- dsf- jitu tonglong 
            t- dsf- 水仙花数， xxx数
            ---https://www.w3resource.com/cpp-exercises/basic/index.php
            t- Print the American flag
                expected io: clear 
            t- find the area of Scalene Triangle
                expected io:
                    Input the length of a side of the triangle : 5
                    Input the length of another side of the triangle : 6
                    Input the angle between these sides of the triangle : 6
                    The area of the Scalene Triangle is : 1.56793
                n28, https://www.w3resource.com/cpp-exercises/basic/index.php
            t- convert temperature in Celsius to temperature in Fahrenheit
                ref. https://www.w3resource.com/cpp-exercises/basic/index.php   
                -
            t- compute the total and average of four numbers
            t- show the diff. size of float, double vars. 
                size of bool? 
                expected: (test cases:)
                    The sizeof(char) is : 1 bytes
                    The sizeof(short) is : 2 bytes
                    The sizeof(int) is : 4 bytes
                    The sizeof(long) is : 8 bytes
                    The sizeof(long long) is : 8 bytes
                    The sizeof(float) is : 4 bytes
                    The sizeof(double) is : 8 bytes
                    The sizeof(long double) is : 16 bytes
                    The sizeof(bool) is : 1 bytes
            t- check the upper and lower limits of integer.
                (use INT_MAX, INT_MIN...) 
                    The maximum limit of int data type :                  2147483647      
                    The minimum limit of int data type :                  -2147483648     
                    The maximum limit of unsigned int data type :         4294967295      
                    The maximum limit of long long data type :            9223372036854775807                                                                    
                    The minimum limit of long long data type :             -9223372036854775808                                                                  
                    The maximum limit of unsigned long long data type :   18446744073709551615                                                                   
                    The Bits contain in char data type :                  8               
                    The maximum limit of char data type :                 127             
                    The minimum limit of char data type :                 -128            
                    The maximum limit of signed char data type :          127             
                    The minimum limit of signed char data type :          -128            
                    The maximum limit of unsigned char data type :        255             
                    The minimum limit of short data type :                -32768          
                    The maximum limit of short data type :                32767           
                    The maximum limit of unsigned short data type :       65535
            t- find the area of any triangle using Heron's Formula.
                Heron's formula states that the area of a triangle whose sides have lengths
                semiperimeter of a polygon is half its perimeter
                exp:
                    Input the length of 1st side of the triangle : 5
                    Input the length of 2nd side of the triangle : 6
                    Input the length of 3rd side of the triangle : 7
                    The area of the triangle is : 14.6969
            t- calculate area of an equilateral triangle
                exp:
                    Input the value of the side of the equilateral triangle: 5
                    The area of equilateral triangle is: 10.8253
            t- calcu. the area of a hexagon
                io:
                    Input the side of the hexagon: 6
                    The area of the hexagon is: 93.5307
            t- compute the shortest distance between two points on the surface of a sphere
                given https://en.wikipedia.org/wiki/Great-circle_distance as ref. 
                    + radians, the calcu. of arc length d 
                        what is latitude? be transfered to angle? radiance? 
                        radians is bet. (0-3.1415... when we have angle bet. 0 to 360? unit circle? )
                io:
                    Input the latitude of coordinate 1: 25
                    Input the longitude of coordinate 1: 35
                    Input the latitude of coordinate 2: 35.5
                    Input the longitude of coordinate 2: 25.5
                    The distance between those points is: 1480.08
            t- gen. primes within 1000000 quickly(not using table, hard for coding)
                io: clear 
            t- mem allocation precisely 
            t- string calculator 
                io clear.
                ltc. 
            t- swap all digits of a decimal number 
            t- from decimal to binary calcu. or, other forms  
                ltc.
            t- swap only two digits, the first and the last 
                -> math calcu. 
            t- string replacement with in a string text 
                io clear. 
            t- find max element in an array with custom comparation func. std::max_ele...
                http://www.cplusplus.com/reference/algorithm/max_element/   
            ---https://edabit.com/challenges/cpp
            t- validate a string by checking if there is any space 
                hasSpaces("hello") ➞ false
                hasSpaces("hello, world") ➞ true
                hasSpaces(" ") ➞ true
                hasSpaces("") ➞ false
                hasSpaces(",./!@#") ➞ false   
            ---https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/ leetcode!    
                restricted, but still, can observe some
            t- paint in command line - loop/ifelse
                triangles
                form of v / other alphabets 
                form of chinese words   
            t- levenshtein distance -later, dp ok 
            t- hanoi: from a to c with help of b 
                recur.                
        ---math related 
            整数问题
                组合数学
                    普通涂色问题 组合数学-Polya定理
                    约瑟夫问题
                    卡特兰数是组合数学中一个常出现在各种计数问题中的数列
                数论问题：
                    辗转相除（两行内）
                    任意进制间的转换
                    大整数的分解
                    求素数
                        https://www.zhihu.com/question/307930531/answer/566185328
                    最大公约数(Gcd)两种算法(Euclid && Stein) 
                数字游戏
                博弈类
            精度
                提高精度
                    高精度四则运算
                    高精度pi计算
                        使用
            高阶问题
                矩阵快速乘法
                快速傅里叶变换
                fibonacci数列 &
                    用数组，可以在linear 时间中完成
                    很多数列问题都可以
                解线性方程组
                    +在图形学中应用广泛，CV中，ML中
                    例如mesh parameterization
                    最小化能量方程
                    -
                解线性规划问题
                    单纯形算法
        ---oj hierarchy （原子问题） 
            DS based tasks(not only stl)
                // heuristics:
                    NP problems(theory review first)
                    oj 
                    books 
                simple-ones, use set, map, 
                list-based 
                    t- ...
                tree-based 
                    basic bin. tree
                    advanced trees:
                    ...
                graph-based 
                created_stru-based 
                t- demostrate xxx DS!!
            Algo. based 
                // algo problems?? NP hard? 
                t- demostrate diff. sorting algos! 
                t- demostrate xxx algos!
            -> vis. and interaction with algos. 
                proj.
            competition 
                huawei 
                tencent 
                ...
            ---
            reasoning, triple analysis(graph)
                ...
        *---mixed problem (+刷题)
            //res 
                http://www.pythontip.com/acm/problemCategory
                https://blog.csdn.net/h273979586/article/details/69786603 
                http://www.pythontip.com/acm/problemCategory
                查找（二分、哈希）：poj3349、poj1002、hdu2141、hdu1025
                串（AC自动机、KMP）：hdu3695、hdu2203、sdut2411、poj2406、hdu1358、hdu3336
                并查集：poj2236、poj2524、poj1182、poj1611、hdu1232
                字典树：poj2503、poj2001、hdu1247、hdu1075、hdu1251
                树状数组：hdu1556、poj1195、poj3321、hdu1541/poj2352
                线段树：poj2155、poj1195、poj3468、poj3264、hdu1556、hdu1698、hdu1754、hdu1166
                划分树：poj2104、sdut2610
            ---unknown mixed source 
                数组右移k位
                AABB空间搜索 ++
                    其实是通过剪枝加快搜索
                    建立一个树结构，只要树高减小，可能能到logN
            ---poj
                poj 1050 最大子矩阵 ++
                    其实是一个矩阵，但是可以简化成数组问题（压扁）
                    原子问题：最大子序列，dp
                poj 3750 小孩报数问题 ++
                    用循环链表更合适 
                    原子问题：循环链表
                jiuduoj 1078 
                    https://www.cnblogs.com/qinduanyinghua/p/6418728.html
                    q- build a tree stru. and then do some operations, what is the best way? 
                        build based on the pre-order and in-order of the tree
                        maybe just pre-order traversal, give the val at the same time? n we can not def. a tree this way 
                            but, for bst tree possible, search tree  
                            (righ child is larger than left)
                    sub- 
                        *create a tree from its pre-order and in-order 
                        *post-order traversal
                        *the stru. of a tree
                    t- create a full bin tree stru., init with 0, do bfs, give them id, and print it out 
                        Level Order traversal, bfs , use a queue 
                        https://www.geeksforgeeks.org/construct-complete-binary-tree-given-array/
                    t- construct a bst tree from given list of val. in pre-order 
                        bst tree, left val < right val  
                    theory- 
                        typedef struct { ... } Foo; 
                            declares an anonymous structure and creates a typedef for it
                            only a name in the typedef namespace.
                            typedef, which you can use to give a type a new name
                            You can use typedef to give a name to your user defined data types as well.
                            use typedef with structure to define a new data type
                            Foo can be used just as a class. 
                    q- assign value to the sub routain? use para. , return val, or global val? 
                        para. val > global val > return val. the expressitivity 
                    q- the idea of bfs? 
                        push to queue, then, expand its child  
        ---linear算法
            排序算法
            字符串
            摊还分析
                简单来说，就是计算某个操作的平均代价，而不是只去关注最坏情形。 
                vector既要连续存储，又要支持无限添加元素，如果没有空间容纳新元素，vector必须分配一个新
                    的而且更大的连续空间(我们假设是新空间大小是旧空间的2倍)，将已有数据复制到新空间里面，
                    然后释放旧空间。(这个操作也叫扩张)
                我们将最坏情况平摊到每一次操作中，将最坏的复杂度尽可能地稀释，得到了一个更有价值的紧确界
                实际上，连续添加N个新元素的总复杂度只有O(N)
                摊还分析最常用的三种技术
                    https://zhuanlan.zhihu.com/p/74559481
                摊还分析的内核永远是从宏观的角度看复杂度，将最坏的复杂度平摊到每一次操作中。
                有了摊还分析，很多数据结构的“冤屈”才得到洗刷。
            dp算法
                动态规划和记忆化搜索确实是一个东西。
                状态转移方程
                https://www.jiqizhixin.com/graph/technologies/9a91aa59-8dc1-4eff-833b-6180ba53cb68
                Bellman Equation
        ---tree算法
            //
                btree一共有四种遍历
                    preorder 
                    inorder 
                    postorder
                    levelorder 
                其中preorder就是dfs，levelorder就是bfs
                levelorder具有唯一性，可以根据bfs，levelorder的顺序建立树
                    但是其他三种不行
                三种之中知道两种就可以恢复出来！！
            创建binary tree 
                idea:
                    Time Complexity: O(n), where n is the total number of nodes in the tree.
                    其实插入和检索可以类似，只是在检索数据的时候赋值而已
                pcode:
                    insertLevelOrder_recur
                        new node at i 
                        node.left = insertLevelOrder_recur(2 * i + 1)
                        node.right = insertLevelOrder_recur(2 * i + 2)
                io: 
                    string str = "abcdefghijklmnopqrstuvwxyz";

                realc++ 层次遍历作为输入
                    ---v1
                        void Cons(Node curNode){
                            curNode.val=Q.pop().val
                            Cons(curNode.left);
                            Cons(curNode.right);
                        }
                        //false! 当然也可以给前序来创建树，那样的话用递归就可以
                    ---v2
                        Node* insertLevelOrder(arr[], Node* root, int i, int n) 
                        { 
                            // Base case for recursion 
                            if (i < n) 
                            { 
                                Node* temp = newNode(arr[i]); 
                                root = temp; 
                        
                                // insert left child 
                                root->left = insertLevelOrder(arr, 
                                        root->left, 2 * i + 1, n); 
                        
                                // insert right child 
                                root->right = insertLevelOrder(arr, 
                                        root->right, 2 * i + 2, n); 
                            } 
                            return root; 
                        } 
                        //too complex!
                    ---v3
                        Node * insertLevelOrder(){
                            root=newNode(a[0]);
                            Queue q;
                            q.push(root);
                            i=0;
                            while(q.size()!=0){
                                curNode=q.pop();
                                if(i<n){
                                    curNode->data()=a[i];
                                }
                                if(2*i + 1 < n){
                                    //has left child 
                                    l=newNode();
                                    curNode->left=l;
                                    q.push(l);
                                }
                                if(2*i + 2 < n){
                                    r=newNode();
                                    curNode->right=r;
                                    q.push(r);
                                }
                                i++;
                            }
                        }
                        //Good!
                    ---recur 
                        void insertLevelOrder(string str, Node*& root, int i, int n)
                        {
                            if (i < n)
                            {
                                root = newNode(str[i]);
                                insertLevelOrder(str, root->left, 2 * i + 1, n);
                                insertLevelOrder(str, root->right, 2 * i + 2, n);
                            }
                        }
                realc++ 先序遍历作为输入
                    是没法直接根据preorder恢复的！ 
                    no-任何一种遍历都是可以恢复的！但是遍历的顺序和idx一定要对应！！！
                        只要是唯一的遍历就ok
                    --- err!
                        Node* PreOrderInsert(a,i){
                            if(i<n){
                                curNode=newNode();
                                curNode->data=a[i];
                                curNode->left=PreOrderInsert(a,i+1);
                                curNode->right=PreOrderInsert(a,i+2);
                            }else{
                                return NULL;
                            }
                        }
                    --- err!
                        //i should be global ; should use NULL to，ok 
                        int i=0;
                        Node *PreOrderInsert(int a[], int n)
                        {
                            if (i < n && a[i]!=NULL)
                            {
                                Node *curNode = (Node *)malloc(sizeof(Node));
                                curNode->data = a[i];
                                i++;
                                curNode->left = PreOrderInsert(a, n);
                                curNode->right = PreOrderInsert(a, n);
                                return curNode;
                            }
                            else
                            {
                                i++;
                                return NULL;
                            }
                        }       
                realc++ 完整代码
                    #include<iostream>
                    #include<cstdio>
                    #include<cstring>
                    #include <string>
                    #include <queue>
                    #include <stack>
                    using namespace std;

                    /* A binary tree node has data,
                    pointer to left child and a
                    pointer to right child */
                    struct Node
                    {
                        char data;
                        Node* left, * right;
                    };

                    /* Helper function that allocates a
                    new node */
                    Node* newNode(char data)
                    {
                        Node* node = (Node*)malloc(sizeof(Node));
                        node->data = data;
                        node->left = node->right = NULL;
                        return (node);
                    }

                    void insertLevelOrder(string str, Node*& root, int i, int n)
                    {
                        if (i < n)
                        {
                            root = newNode(str[i]);
                            insertLevelOrder(str, root->left, 2 * i + 1, n);
                            insertLevelOrder(str, root->right, 2 * i + 2, n);
                        }
                    }

                    int idx = 0;
                    void insertPreOrder(string str, Node*& curnode, int n)
                    {
                        if (idx < n)
                        {
                            curnode = newNode(str[idx++]);
                            insertPreOrder(str, curnode->left, n);
                            insertPreOrder(str, curnode->right, n);
                        }
                    }

                    void inOrder(Node* root)
                    {
                        if (root != NULL)
                        {
                            inOrder(root->left);
                            cout << root->data << " ";
                            inOrder(root->right);
                        }
                    }

                    void preOrder(Node* root)
                    {
                        if (root != NULL)
                        {
                            cout << (char)root->data << " ";
                            preOrder(root->left);
                            preOrder(root->right);
                        }
                    }

                    void bfs(Node* root) {
                        std::queue<Node*> q;
                        q.push(root);
                        while (!q.empty()) {
                            Node* cur = q.front();
                            q.pop();
                            if (cur != NULL) {
                                cout << cur->data << " ";
                                q.push(cur->left);
                                q.push(cur->right);
                            }
                        }
                    }

                    void dfs(Node* root) {
                        std::stack<Node*> s;
                        s.push(root);
                        while (!s.empty()) {
                            Node* cur = s.top();
                            s.pop();
                            if (cur != NULL) {
                                s.push(cur->right);
                                s.push(cur->left);
                                cout << cur->data << " ";
                            }
                        }
                    }

                    int main()
                    {
                        string str = 
                            //"abcdefghijklmnopqrstuvwxyz";
                            "abdecfg";
                        //int arr[] = { 1, 2, 3, 4, 5, 6, 6, 6, 6 };
                        //int n = sizeof(str) / sizeof(char) - 1;
                        int n = 7;
                        //int n = sizeof(arr) / sizeof(arr[0]);
                        Node* root = NULL;
                        //insertLevelOrder(str, root, 0, n);
                        insertPreOrder(str, root, n);

                        std::cout << "in-order:" << std::endl;
                        inOrder(root);
                        std::cout << "\npre-order:" << std::endl;
                        preOrder(root);
                        std::cout << "\nbfs:" << std::endl;
                        bfs(root);
                        std::cout << "\ndfs:" << std::endl;
                        dfs(root);
                    }               
            基本树的各种遍历
                +
                    To convert an inherently recursive procedures to iterative, 
                        we need an explicit stack
                    * stack based iterative process 
                    Using Stack is the obvious way to traverse 
                        tree without recursion.
                preorder_recur 
                    pcode:
                        preorder_recur
                            visit node
                            preorder_recur(node.left)
                            preorder_recur(node.right)
                    realc++:
                        void preOrder(Node* root)
                        {
                            if (root != NULL)
                            {
                                cout << (char)root->data << " ";
                                preOrder(root->left);
                                preOrder(root->right);
                            }
                        }   
                inorder_recur 
                    ---
                        inorder_recur
                            inorder_recur(node.left)
                            visit node 
                            inorder_recur(node.right)
                postorder_recur 
                    ---
                        postorder_recur
                            postorder_recur(node.left)
                            postorder_recur(node.right)
                            visit node 
                preorder non-recur &toimp
                    --- 
                        push root at the top of a stack
                        while stack is not empty.
                            Pop an item from stack and print it.
                            Push right child
                            Push left child
                    //stack<node *> nodeStack;
                inorder non-recur &toimp
                    ---https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/
                        1) Create an empty stack S.
                        2) Initialize current node as root
                        3) Push the current node to S and set current = current->left until current is NULL
                        4) If current is NULL and stack is not empty then 
                            a) Pop the top item from stack.
                            b) Print the popped item, set current = popped_item->right 
                            c) Go to step 3.
                        5) If current is NULL and stack is empty then we are done. 
                postorder non-recur &toimp
                    ---https://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/
                        1.1 Create an empty stack
                        2.1 Do following while root is not NULL
                            a) Push root's right child and then root to stack.
                            b) Set root as root's left child.
                        2.2 Pop an item from stack and set it as root.
                            a) If the popped item has a right child and the right child 
                            is at top of stack, then remove the right child from stack,
                            push the root back and set root as root's right child.
                            b) Else print root's data and set root as NULL.
                        2.3 Repeat steps 2.1 and 2.2 while stack is not empty.
        ---graph算法
            bfs广度优先搜索
                实际上可以用数组和结构模拟（数组元素是结构）
                时间复杂度为O(V+E).即是图邻接表大小的线性函数。
                pcode :
                    init Queue; boolean visited ;
                    while(q=Q.pop()){
                        if(Obj==q){// can have more options 
                            return q;
                        }else{
                            Q.push(q->left())
                            Q.push(q->right())// can have more childs 
                            q.visited = true ;
                        }
                    }
                code tips:
                    Queue:
                        queue<Point>q;-->#include <queue>  
                        q.front();
                        q.pop();
                        q.push();
                eg.
                    0.Construct a complete binary tree from given array
                    1.given [3,9,20,null,null,15,7] return value 
                    2.find Minimum in log time 
                        given [3,9,20,15,7] find Minimum
                        conpare with linear method (one while loop)
                    .
                ref
                    https://www.geeksforgeeks.org/construct-complete-binary-tree-given-array/
                    https://stackoverflow.com/questions/33852623/create-binary-tree-in-level-order-from-array
            
                
        ---computational geometry
            空间剖分（space partitioning）
                三角剖分算法
                Delaunay三角剖分
            图的对偶变换
            凸包与半空间求交
            叉乘、判线段相交、然后写个凸包. 
            线段交点、多角形面积公式.                     
    ---
    preview_pass 
        seedfrombookcpt
        seedfrompapercpt
        seedfromcode 
            base:stl 
                codereading 
                taskdesigned 
                STL has four components
                    Algorithms
                    Containers
                    Functions
                    Iterators
            mywork    
            similar to: boost lib
                usable across a broad spectrum of applications.
                Boost as a valuable source for additions to the Standard C++ Library
                Boost provides free peer-reviewed portable 
                    * C++ source libraries.
                supports research and education into the best possible uses of C++ and libraries developed for it
                https://www.boost.org/doc/libs/1_73_0/libs/libraries.htm#Image-processing
                https://www.boost.org/doc/libs/1_73_0/libs/libraries.htm#Data
                https://www.boost.org/doc/libs/1_73_0/libs/libraries.htm#Algorithms
    ---
    book_pass
        ---struc.
            //很多数据结构最好用stl实现（如果非要创造新的），在c++ stl中可以复用！
            book--算法竞赛入门经典
                基础题目
                数据结构的应用
                    // some tasks, not so much theory 
                    ---queue and stack
                    t- pukestack--given a stack of puke, from 1 to 7, get the first one and put the one behind to the buttom
                        simulate this process 
                        in:7 out:1357426
                    t- train inversion problem, judge if it is possible for the given order!
                        in:A 12345, B 54321 out:ok 
                        op108
                    t- move the ball-- 
                        move a ball n to the left of m: A n m 
                        move a ball n to the righ of m: B n m
                            given a list initialized with 1-k, output the result for given operations 
                        op109 
                        shift the sub array, but ineffecient 
                    q- 什么是程序对拍？ op112 
                    t- construct a testing enviroument? 
                        an other prog achieving the same goal 
                        random gen. or data gen. 
                        batch file to compare the results 
                    t- the falling ball -- release I balls at the root of the tree with depth D 
                        leaves are all negative at first. when a ball pass by a leave, the state changes oppositely
                        ask: where is the last posi. found? 
                        output the id(ids are from 1 to N )
                        in:D I out:the id(indecates the position)
                        f- maybe do not need to imp. a real tree stru.! ... 
                            a possible stru. rep. the tree stru. is: using the "array representation"
                        op115
                        q- how can be made more effecient? 
                            simulate directly the last case! 
                    q- the tree rep.s x2
                        structured rep. , array rep.
                        array rep. not so good beacause of the mem. consumption 
                    t-  build a tree with a list of "triples", or just two compoments  
                        op117  in: (3,LL)(7,RL)(19,RR)(5,)()
                        can be extended to triples 
                        q- what may be the possible risk when we have multiple input val.? 
                            mem. leak 
                    t- build a tree with ids the same order as bfs, build the tree the same time 
                        as bfs traversal 
                        -standard approach
                        with a given string, arr val 
                        i dev.
                    q- what may be the reason that malloc fails? 
                        no enough mem. 
                    q- what is 显示图算法，隐式图算法？ 
                    q- 泄露的内存啥时候回收？ 
                        整个程序结束之后
                    q- 什么是内存泄露？ 
                    q- why we have to manage mem.? avoid mem leaks? 
                    "结构体+数组"方式处理动态数组结构
                    q- 树结构的先序遍历，中序后续的定义？
                        递归定义，先序遍历就是先访问节点，再访问左子节点，而后访问右子树 
                    ---op121
                    t- build tree, and give the post traversal for the given preorder traversal and 
                        in-order traversal op121 
                        in: DBACEGF ABCDEFG out:ACBFGED
                        in two ways: one use "fake binary tree", the other use a real tree stru. 
                        thought: see left and right child as subset, do the building step recursevely 
                    q- what is the main diff. bet the graph? than seq. and strucdtural stru.? 
                        op121 
                    t- connected component detection under binary image 
                        op122
                        q- can both bfs and dfs be used? maybe not. use real image as input? !
                        gen. images randomly under cgv framework
                        in: an binary image out:a number indicates connected compoments
                        psoudo:
                            dfs()
                                dfs(x-1,y-1); dfs(x,y-1); dfs(x+1,y-1);
                                dfs(x-1,y  );             dfs(x+1,y  );
                                dfs(x-1,y+1); dfs(x,y+1); dfs(x+1,y+1);// a stencil method 
                            for 
                                for 
                                    if("(ij)is black")
                                        "dfs from (ij)"
                        imp. a non-recur. version, use stack instead 
                    q- what is implicit stack? explicit? 
                    t- the maze problem, find shortest path for the given two points.
                        in: 
                        for every point we can find a shortest path! and 
                            
                        
                    

                    
                    

                    
                        
                    

                    

                            
                算法部分
            book--data-structures-and-algorithms-in-c++
                aim:
                    basic concepts about the ds, how diff. opertions are def., the adv. and disadv. of the diff. ds. 
                    as for coding tasks, we should be able to imp. and do simple operations on them! 
                    concepts:
                        def. + relationships + corner cases + ...
                    tasks:
                        idea, psoudo code, code, ...
                plan:
                    ch13 - ch4.1 - 
                ---
                mixed 
                    q- what are Iteration structures, Decision structures in programming lan.
                        for-loops and while-loops
                    it does not provide a comprehensive treatment of C++
                    Pseudo-Code
                ---op78
                1.7 Writing a C++ Program, design! 7p
                    q- what is protocol in the context of oop? op78 
                        The set of behaviors for a class
                    q- what shall be designed? 
                        Defining the classes, together with their member variables and member functions
                    imp. the skills in performing these tasks over time
                    experience teaches him
                    prior to writing actual code
                    Pseudo-code is a mixture of natural language and high-level programming
                        constructs
                    q- def. of Pseudo-code op78 
                    describe the main ideas behind a generic implementation
                    generic implementation
                    q- how to express assignment statements in psoudo code? if else branch? 
                        Decision structures, While-loops, Repeat-loops, comments? op79
                        left arrow sign (←) as the assignment operator in assignment statements(= in c++)
                        we use the equal sign (=) as the equality relation in Boolean expressions(== in c++)
                        name(arg1,arg2, . . . ) declares a new function “name” and its arguments.
                        if condition then true-actions [else false-actions]
                        while condition do actions
                            this used to indicate what actions should be included in the loop actions.
                        repeat: repeat actions until condition
                        For-loops: for variable-increment-definition do actions.
                        Array indexing, consistant with c++
                        Member function calls: object.method(args)
                        Comments: { Comment goes here. }. We enclose comments in braces.
                    we should not gloss over important steps.
                    skills shoudl be refined through practice
                    design patterns provide templates for defining classes and the interactions between these classes
                    design patterns acc. the process of code designing 
                    q- what is  Class-Responsibility-Collaborator (CRC) cards
                        helps to subdivide the work required of a program.
                    left-hand side of the card, we write Responsibilities 
                    On the right-hand side, we list the collaborators for this component
                    The design process iterates through an action/actor cycle
                    q- what is adv. of this method? 
                    each component will have a small set of responsibilities and collaborators
                    keep our programs manageable
                    An alternative to CRC cards is the use of UML (Unified Modeling Language) 
                        diagrams to express the organization of a program
                    q- what are standard visual notation for prog. designing? 
                    Describing algorithms in pseudo-code is the key step 
                    using either an independent text editor
                    or the editor embedded in an integrated development environment (IDE)
                    Once we have eliminated all syntax errors and created the appropriate compiled code
                    q- describe the coding process! op80 
                    much has been written about good coding style. Here are some of the main principles.
                    *be meaningful
                        Use comments that add meaning to a program
                    *be standard 
                        Indent statement blocks
                        q- why use two spaces in the book? 
                            avoid having our code overrun the book’s margins.
                        q- class functions, varibles should have consistent order?x4 
                            1. Public types and nested classes
                            2. Public member functions
                            3. Protected member functions (internal utilities)
                            4. Private member data
                    q- what is testing process? debugging?
                        Testing is the process of [verifying] the correctness of a program
                        debugging is the process of tracking the execution of a program and discovering the errors in it
                    Testing and debugging are often the most time-consuming activity in the
                        development of a program
                    over all possible inputs is usually not feasible, we should use tech. from sft! 
                        eg. method coverage, special cases, boundary cases
                        s- code testing within his publications
                        Bottom-up testing and top-down testing 
                        we need a replacement for the method sometimes  
                    it is also advantageous to run the program on a large collection of randomly generated inputs.
                    The simplest debugging technique consists of using print statements
                    track the values of variables
                    q- what is a debugger?
                        a specialized environment for controlling and monitoring the execution of a program.
                        conditional breakpoints?
                4.1 The Seven Functions Used in This Book -- for complexity analysis 10p
                ---
                3 Arrays, Linked Lists, and Recursion - 46p
                    sorting an object representation
                    name of the person earning this score also as var. 
                    we just want two fields, score and name
                    accessor member functions
                    *use pointer to indicate an array, as Private variable
                    The number of times we perform dep. on the number we need to shift 
                    array-based solution
                    q- Algorithm InsertionSort(A): op134  
                    q- c- convert the psoudo code to real code op134 
                    s- alg analysis, worst case
                    q- statement creates a two-dimensional “array of arrays,”
                    Given integer variables i and j, we could output the element of row i and column j
                    q- what should be done If the dimensions of a two-dimensional array are not known in advance?
                    the matrix is of type int**
                    h- can be expressed as "a pointer to a pointer of integers"
                    q- generate our matrix, allocate memory? op137
                    we can access its elements just as before
                    deallocating the matrix involves reversing these steps
                    q- t- array-based imp. , pointer based, stl vector based x3 
                        “vector<vector<int>>.” Let us declare M to be of this type. 
                        create, allocate, store dataset, printout with those types 
                    q- why M(n) does not work? fix?
                        default constructor is called for each
                        row, and the default is to construct an empty array
                        make use of a nice feature of the vector class constructor, pass an other arg. 
                        vector< vector<int> > M(n, vector<int>(m));
                    the STL vector class automatically takes care of deleting its members!
                    q- a simple application of two-dimensional arrays for implementing a positional game?
                        Tic-Tac-Toe board and the array representing
                    ---op141
                    Singly Linked Lists
                    resizing an array difficult
                    important alternate implementation of sequence, known as the singly linked list
                    q- what is a Singly Linked Lists?
                        each node stores a pointer, called next, to the next node of the list.
                        and store an element
                    q- what is pointer hopping, link hopping? op141
                    head and tail of the list
                    a tail is a node having null next reference
                    q- which two classes are needed to def. a single linked list? 
                    q- why make the linked list class a friend? op141 
                    q- t- make use of the linked list, store, sort a list of students with they records! op143 
                    h- we should not use vactor in a linked list, they are imp. interally as linked list!
                    A more careful implementation?
                        would throw an exception if the list were empty
                    q- why can not directly del. the last node?
                        we need to update the next link of the node immediately preceding the deleted node
                    q- what is the time needed for del. the last node within a single linked list? op145 
                    q- may it slow, how to remedy this? 
                    q- what is a generic single linked list?SLinkedList?  diff. bet. the one before? 
                        element type is a character string.
                        we always want sth. that works for an arbitrary element type 
                            through the use of C++’s template mechanism.
                    resulting generic singly linked list class is called SLinkedList.
                    data type “string” have been replaced by “E.”
                    q- access the node and the list with type E ? 
                    h- the class is SLinkedList<E> and the associated node is SNode<E>.
                    q- housekeeping functions? s- 
                    each def. is prefaced by the template specifier template <typename E>
                    q- t- imp. a generic single linked list and store, sort, print student data with it! op145 
                    h- we can create a list of strings and a list of int with ease 
                    h- we often sacrifice generality for simplicity
                        and avoid the use of templated classes in some of our examples.
                    h- a high notational burden has been found in c++ 
                    q- why remove an ele. is a hard task ? 
                        we do not have a quick way of accessing the node immediately preceding the one we want to remove
                    is a type of linked list that allows us to go in both directions
                    q- what is Header and Trailer Sentinels op147 
                        a trailer node just after the tail of the list.
                    q- what is typically included in a node stru.? 
                        next pointer and prev pointer  
                    q- what does a enpty double linked list looks like? 
                        An empty list would have these sentinels pointing to each other.
                    h- there is a null prev pointer for the header and the same thing for tail node 
                    q- operations needed to  Insertion into a Doubly Linked List? x4 op148 
                        cur new node > other two nodes 
                        prev pointer > next pointer 
                        those two "observed rules" -- comes with our intuitive in life 
                    q- del opertions needed wrt. the above? x3 
                        other two nodes > cur node 
                        prev pointer > next pointer
                    We refer to this operation as the [linking out] of v
                    q- an alternative to use template when creating stru.? op149 
                        a typedef statement that defines the element type
                    q- what are typically def. when creating a stru.? -me
                        node stru. 
                        whole stru. (includes more info. about the stru. like the depth of a tree... 
                            not only one pointer to Node )
                    no nodes other than the sentinels
                    q- how can we constructe a double linked list? to initialize? 
                    q- what are basic class accessors op151 
                    q- what is the perpose for the book? not for algs? for generic usage ? y 
                        We could have enhanced these functions by throwing an exception
                    q- how to get the front ele.?   
                        return header−>next−>elem;
                    q- what is Accessor functions 
                    q- what is the acc.bility of local utility function? which keyword to use?
                    q- how to add a node after a double linked list? x4 
                        cur new node > other two nodes 
                        prev pointer > next pointer 
                        when insert... 
                    q- t- imp.a double linked list and do some operations op151 
                    The public member functions addFront and addBack both invoke this utility function.
                    as desired/ as expected/ what we want 
                    q- why are we providing sentinel nodes?
                    There are many more features can be added 
                        and more stru. and be imp. conceptually 
                    We have also performed no error checking in our implementation.
                    more robust implementation
                    q- Circularly Linked Lists?
                        the nodes are the same as before, but linked into as a cycle 
                        we can all the nodes and cycle back
                    q- where to start?
                        special node, which we call the cursor.
                    node, that immediately following this in the circular order, which is called the front
                    q- what happens if we were to cut the link between the node referenced by the cursor and this node’s
                        immediate successor?
                        become single linked list 
                        op153 
                    we provide a typedef statement that defines the element type Elem, which is the base type 
                    q- c++11 construction initialization? op155 
                        use : cursor(NULL)  {}
                    q- how to advance the cursor to the next element? 
                        cursor = cursor-> next;
                    q- t- insertion, del., clear the circular linked list? in c++? op155
                    ---
                    q- t- Maintaining a Playlist for a Digital Audio Player
                        The songs of the player are stored in a circular list
                        the aim was to illustrate 
                    q- illustrate the effect of advance() by giving a preview of the ele. in [] op157 
                    q- Reversing a Linked List, how can achieve this? with a double linked list. t- imp. this in c++ op157 (not hard)
                        with two steps, use a tmp. list.
                        1. copy inversly from the first to the tmp. list 
                        2. copy directly the opposite position 
                    ---op158
                    q- repetition can be achieved by writing loops and ? 
                        this, provides an elegant and powerful alternative
                    lets compute a factorial function
                    q- what is a factorial function? 
                        def. as the product of the integers from 1 to n
                    q- t- wrte a function to compute fraction: factorial(n)   
                        input: number, output: computed number 
                    h- calcu. by hand and observe some facts before start to coding 
                    q- the recursive definition of that func. ? how can it be transfered to a code? op158  t- op159 
                        base cases, which are defined nonrecursively in terms of fixed quantities
                        It also contains one or more recursive cases
                    The repeated recursive invocations
                    take the place of looping
                    ---op159 
                    q- what is recursion trace
                        Each entry of the trace corresponds to a recursive call
                    q- draw the recursion trace for the para. 4 op159 
                    q- what is the adv. of a recursion? x2 
                        short and easy to understand 
                        in this case, no compelling reason for preferring recursion over iteration, it is only a simple example 
                    ---op160
                    an other example is Drawing an English Ruler
                    q- what can be the core idea for solving this problem? 
                        a central tick length L can be subdevided as:
                            An interval with a central tick length L−1
                            A single tick of length L
                            An interval with a central tick length L−1
                    q- why is it suitable to be solved by a recursion function? op161
                    q- what are key points of a recursion func.?
                        sub-task 
                            repetitive structure present in many problems
                            avoid complex case analyses and nested loops
                            more readable algorithm descriptions, while still being quite efficient.
                            have a repeated similar structural form
                        when terminates, a condition 
                        which para. will be passed, or global var.  
                    q- what happens when a recursion terminates? 
                        reaches its base case 
                    q- t- imp. the drawRuler task 
                    q- Illustrating Ruler Drawing using a Recursion Trace op162 
                    q- how to express "the same to others"? 
                        pattern repeats below 
                        not shown, but it is identical to the first
                    makes a call to itself
                    recursive call, recursion function
                    ---op163 
                    recursion is a useful way for defining objects
                    h- Modern operating systems define file-system directories in a recurseve way 
                    h- argument-list are def. in a recur. way 
                    h- Russian Matryoshka dolls.
                        Each doll is made of solid wood or is hollow and contains another Matryoshka doll
                    ---op164 
                    q- def. of Linear Recursion
                        at most one recursive call each time it is invoked.
                    q- how Summing the Elements of an Array Recursively? 
                    q- typically stru. of linear recursion?
                    we similarly use recursion traces for the recursive sorting algorithms of Sections 11.1 and 11.2
                    q- for the summing task, when will the first addition happends? 
                        after how many steps? 
                    q- illu the process with a diagram: recursion trace op165 
                    q- the complexity of such a summing? 
                        time roughly proportional to n
                        space: need a constant amount of memory space for each of the n boxes in the trace
                    q- t- Reversing an Array by Recursion: subtask + illustrate + psoudo algo + code
                        the first element becomes the last, the second element becomes second to the last
                    q- proof that guaranteed to terminate? op166 
                    subdivide this problem to define problems that have the same general structure as the original problem
                    facilitate similar-looking subproblems
                    we can find subtasks by work out the problem on a few concrete examples       
                    q- drawbacks of the recursion ? how to solve?
                        When computer memory is at a premium, then it is useful to derive non-recur. version 
                        this can be done using a stack stru. 
                    q- what is the last thing this algorithm does for the fraction function example in a loop? (linear recur.)         
                        addition, not recur. -- it means that it does not use tail recur. 
                    q- can we convert easily when a recur. call is the last thing we did during the function(is tail recur.)
                        if the algori. uses tail recur., how can we convert it to non-recur. version? 
                            iterating through the recursive calls
                    q- transfer the recur. version of reversin an array to non-recur. one. (it has a tail recursion)
                        IterativeReverseArray(A,i,j) op167
                    ---op168 Binary Recursion
                    q- def. of a binary recursion? 
                        makes two recursive calls at the same time 
                        be used to solve two similar halves of some problem
                    q- examples using binary recur.? 
                        english ruler problem 
                        summing of an array 
                    q- how can we apply binary recur. to sum an array? op168 psoudo code? t- code? 
                    h- the summing problem is very good to illustrate the recurion, as it can be applied to multiple recurion! code! 
                    h- the value of parameter n is halved at each
                    q- what is the depth of the problem BinarySum(0,8)? 
                        1 + log2n
                    q- what is the space consumtion? op168 
                    q- what is the time consumption? 
                        linear 
                    h- it will looks like a tree, has a tree shape 
                    q- t- Computing Fibonacci Numbers via Binary Recursion
                        math def., recur. def. , recur. prog. op169 
                    q- why summing has a linear complexity and fibonacci computation task(using binary recurion) need expotional time wrt. k 
                        F(k) call. 
                        is really a linearly recursive problem
                    q- what is the complexity of a fibonaqi computation using binary recurion? linear recurion? 
                    q- does it have the same amount of computation when using binary recur. and linear recur.? n 
                    compute Fibonacci numbers is very inefficient.
                    q- how to calcu. the fibonaqi numbers effeciently? op170 psoudo code, code t- 
                    q- does it always true, linear recurion is more or the same effecient than binary recurion? p- seems like that 
                    This performance is significantly faster than the exponential time
                    q- how can we make this calcu. more effecient? 
                        by dynamic programming, keep trace of prev val. 
                    ---op171 Multiple Recursion
                    q- how multi. recur. be used? 
                        solve a combinatorial puzzle
                        find a possible path traversing a maze x4 recur. 
                    If the number of possible configurations is not too large
                    q- what means possible configurations op172 
                    q- how can we improve the prog in this case? 
                        heuristics 
                9 Hash Tables, Maps, and Skip Lists 50p
                5 Stacks, Queues, and Deques 30p
                    ---op218 
                    q- what is a stack? queue 
                        A stack is a [container of objects] supporting LIFO 
                    h- Internet Web browsers store the addresses of recently visited sites on a stack
                    h- Text editors usually provide an “undo” mechanism
                    q- complexity for stack operations?
                        each function runs in constant time
                    Performance of an array-based stack
                    q- the underlying imp. of the stack stru? 
                        STL vector class
                    q- t- use stl stack, do some operations! code! 
                    q- does it support exceptions in stl imp. ? 
                        n, it is up to the programmer to be sure that no such illegal accesses are attempted.
                    we can def. an abstract data type first 
                    principal concern is specifying the Application Programming Interface (API),
                    a list of members that any implementation must provide.
                    q- The informal interface for the stack ADT op221 
                    q- why some func. are def. with the keyword const? 
                        const, which informs the compiler that they do not alter the contents of the stack
                    h- pop does not return the element that was popped
                    c
                6 List and Iterator ADTs 35p
                ---
                7 Trees  43p
                8 Heaps and Priority Queues 40p
                10 Search Trees 69p
                14 Memory Management and B-Trees 30p
                ---
                13 Graph Algorithms 61p

                ---    
                +11 Sorting, Sets, and Selection(algo part quick view)
            book--Data Structures and Algorithm in c++(ds part)
            book--Esam Halim Houssein Abd El-Halim_4- Data-Structure Using C++ Malik
            book--
            book--
        ---algos
            book--程序员实用算法
            book--Data Structures and Algorithm in c++(algo part)
            book--Elementary Algorithms  
            book--Algorithm Design
            book--算法导论 en
            book--算法java
                ch01
                ch02 
                    ...
                ch03 
                ch04 
                ch05 
                ch06
            book--图论算法及其MATLAB实现
            book--挑战编程程序设计竞赛训练手册
            book--程序员面试题精选：C++_算法_微软_google
            book--计算机程序设计艺术（第一卷）高清中文版
            online--
    ---
    paper_pass
    ---
    code_pass      
        code--interview_compet
            定期比赛网站
                Bestcoder：我们常打的比赛，题目质量待考究，不过用来每周练练手还是不错的。
                Codeforces：题目质量较高，你的得分rating也是未来找工作的一个可信度很高的衡量标准。
                Topcoder：没打过，听说很难。
            华为2016校园招聘上机笔试题
            华为挑战赛
            国际大学生程序设计竞赛例题解
        code--taskbesedreview---prog. task list -- from beginner to expert  
            ---lan. spec.
                // not so much for oj coding 
                mixed
                    t- demostrate map/hash/list/vector/heap... usage!!
                    t- demostrate xxx usage!!
                File IO
                    read/write file 
                    ...
                Network
                    ... 
            ---Beginner Exercises 
                 
        code--build a data processing framework
            data 
                https://www.kaggle.com/AnalyzeBoston/crimes-in-boston
                    date and location info 
                https://www.kaggle.com/gsi-japan/global-map-japan-data/downloads/global-map-japan-data.zip/1
                    img info
                https://www.kaggle.com/doit-intl/autotel-shared-car-locations
                    location information 
                https://www.kaggle.com/open-flights/flight-route-database
                    route information 
                https://www.kaggle.com/fivethirtyeight/uber-pickups-in-new-york-city
                    time and adress data info 
                https://www.kaggle.com/berkeleyearth/climate-change-earth-surface-temperature-data
                    temperature and place 
                https://www.kaggle.com/google/google-landmarks-dataset#train.csv
                https://www.kaggle.com/c/landmark-retrieval-challenge
                    not c++ / deep lerning project 
                https://www.kaggle.com/START-UMD/gtd
                    location , summary xxx
                
            persers 
                csv reader  
                    https://github.com/ben-strasser/fast-cpp-csv-parser
                        head only 
                    https://github.com/vincentlaucsb/csv-parser
                    https://github.com/d99kris/rapidcsv
                json reader 
                    https://github.com/dropbox/json11
                    https://github.com/open-source-parsers/jsoncpp
                    https://github.com/taocpp/json
                    https://github.com/nbsdx/SimpleJSON
        code--build an algo. lib.